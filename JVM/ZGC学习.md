主要参考链接<https://www.secpulse.com/archives/137305.html>

ZGC适用于大内存低延迟服务的内存管理和回收

ZGC希望在对吞吐量影响不大的前提下，实现在任意堆内存大小下都可以把垃圾收集的停顿时间限制在10ms以内的低延迟

# 理论学习

ZGC收集器是一款基于Region内存布局的，（暂时）不设分代的，使用了读屏障、染色指针和内存多重映射等技术来实现可并发的标记-整理算法的，以低延迟为首要目标的一款垃圾收集器

ZGC采用基于Region的堆内存布局，ZGC的Region具有动态性——动态创建和销毁，以及动态的区域容量大小，在x64硬件平台下，ZGC的Region可以具有大、中、小三类容量

* 小型Region（Small Region）：容量固定为2MB，用于放置小于256KB的小对象。

* 中型Region（Medium Region）：容量固定为32MB，用于放置大于等于256KB但小于4MB的对象。

* 大型Region（Large Region）：容量不固定，可以动态变化，但必须为2MB的整数倍，用于放置4MB或以上的大对象。每个大型Region中只会存放一个大对象，这也预示着虽然名字叫作“大型Region”，但它的实际容量完全有可能小于中型Region，最小容量可低至4MB。大型Region在ZGC的实现中是不会被重分配（重分配是ZGC的一种处理动作，用于复制对象的收集器阶段，稍后会介绍到）的，因为复制一个大对象的代价非常高昂。

![image-20211202165050817](https://raw.githubusercontent.com/liang636600/cloudImg/master/images/image-20211202165050817.png)

**染色指针技术**：  

**背景：** 

追踪式收集算法的标记阶段就可能存在只跟指针打交道而不必涉及指针所引用的对象本身的场景。例如对象标记的过程中需要给对象打上三色标记，这些标记本质上就只和对象的引用有关，而与对象本身无关——某个对象只有它的引用关系能决定它存活与否，对象上其他所有的属性都不能够影响它的存活判定结果。

HotSpot虚拟机的几种收集器有不同的标记实现方案，有的把标记直接记录在对象头上（如Serial收集器），有的把标记记录在与对象相互独立的数据结构上（如G1、Shenandoah使用了一种相当于堆内存的1/64大小的，称为BitMap的结构来记录标记信息），而 **ZGC的染色指针是最直接的、最纯粹的，它直接把标记信息记在引用对象的指针上** 。

**内容：** 

染色指针是一种直接将少量额外的信息存储在指针上的技术。在AMD64架构中只支持到52位（4PB）的地址总线和48位（256TB）的虚拟地址空间，所以目前64位的硬件实际能够支持的最大内存只有256TB。此外，操作系统一侧也还会施加自己的约束，64位的Linux则分别支持47位（128TB）的进程虚拟地址空间和46位（64TB）的物理地址空间，64位的Windows系统甚至只支持44位（16TB）的物理地址空间。

![image-20211202194530161](https://raw.githubusercontent.com/liang636600/cloudImg/master/images/image-20211202194530161.png)

对于linux而言，剩下的46位中将其高4位提取出来存储四个标志信息。通过这些标志位，虚拟机可以直接从指针中看到其引用对象的三色标记状态、是否进入了重分配集（即被移动过）、是否只能通过finalize()方法才能被访问到。缺点是直接导致ZGC能够管理的内存不可以超过4TB（2的42次幂），也不能支持压缩指针（-XX:+UseCompressedOops）

**优点：**

* 染色指针可以使得一旦某个Region的存活对象被移走之后，这个Region立即就能够被释放和重用掉，而不必等待整个堆中所有指向该Region的引用都被修正后才能清理
* 