主要参考链接<https://www.secpulse.com/archives/137305.html>

ZGC适用于大内存低延迟服务的内存管理和回收

ZGC希望在对吞吐量影响不大的前提下，实现在任意堆内存大小下都可以把垃圾收集的停顿时间限制在10ms以内的低延迟

# 理论学习

ZGC收集器是一款基于Region内存布局的，（暂时）不设分代的，使用了读屏障、染色指针和内存多重映射等技术来实现可并发的标记-整理算法的，以低延迟为首要目标的一款垃圾收集器

ZGC采用基于Region的堆内存布局，ZGC的Region具有动态性——动态创建和销毁，以及动态的区域容量大小，在x64硬件平台下，ZGC的Region可以具有大、中、小三类容量

* 小型Region（Small Region）：容量固定为2MB，用于放置小于256KB的小对象。

* 中型Region（Medium Region）：容量固定为32MB，用于放置大于等于256KB但小于4MB的对象。

* 大型Region（Large Region）：容量不固定，可以动态变化，但必须为2MB的整数倍，用于放置4MB或以上的大对象。每个大型Region中只会存放一个大对象，这也预示着虽然名字叫作“大型Region”，但它的实际容量完全有可能小于中型Region，最小容量可低至4MB。大型Region在ZGC的实现中是不会被重分配（重分配是ZGC的一种处理动作，用于复制对象的收集器阶段，稍后会介绍到）的，因为复制一个大对象的代价非常高昂。

![image-20211202165050817](https://raw.githubusercontent.com/liang636600/cloudImg/master/images/image-20211202165050817.png)

---

**三色标记:** 把遍历对象图过程中遇到的对象，按照“是否访问过”这个条件标记成以下三种颜色

* **白色：表示对象尚未被垃圾收集器访问过** 。显然在可达性分析刚刚开始的阶段，所有的对象都是白色的，若在分析结束的阶段，仍然是白色的对象，即代表不可达
* **黑色：表示对象已经被垃圾收集器访问过，且这个对象的所有引用都已经扫描过** 。黑色的对象代表已经扫描过，它是安全存活的，如果有其他对象引用指向了黑色对象，无须重新扫描一遍。黑色对象不可能直接（不经过灰色对象）指向某个白色对象。
* **灰色：表示对象已经被垃圾收集器访问过，但这个对象上至少存在一个引用还没有被扫描过**

对象只有被黑色对象引用才能存活，扫描完成后，黑色对象就是存活对象，白色对象就是可回收对象

如果用户线程与收集器是并发工作，收集器在对象图上标记颜色，同时用户线程在修改引用关系——即修改对象图的结构，这样可能出现两种后果

* 一种是把原本消亡的对象错误标记为存活，下次收集清理掉就好
* 另一种是把原本存活的对象错误标记为已消亡，程序肯定会因此发生错误

举例：

![image-20211202165217030](https://raw.githubusercontent.com/liang636600/cloudImg/master/images/image-20211202165217030.png)

当且仅当以下两个条件同时满足时，会产生“对象消失”的问题，即原本应该是黑色的对象被误标为白色：

* 赋值器插入了一条或多条从黑色对象到白色对象的新引用；

* 赋值器删除了全部从灰色对象到该白色对象的直接或间接引用

解决并发扫描时对象消失问题，只需要破坏这两个条件的任意一个，两种解决方案：增量更新与原始快照

* 增量更新破坏的是第一个条件，当黑色对象插入新的指向白色对象的引用关系时，就将这个新插入的引用记录下来，等并发扫描结束之后，再将这些记录过的引用关系中的黑色对象为根，重新扫描一次。简化理解为，黑色对象一旦新插入了指向白色对象的引用之后，它就变回灰色对象了
* 原始快照当灰色对象要删除指向白色对象的引用关系时，就将这个要删除的引用记录下来，在并发扫描结束之后，再将这些记录过的引用关系中的灰色对象为根，重新扫描一次。简化理解为，无论引用关系删除与否，都会按照刚刚开始扫描那一刻的对象图快照来进行搜索

CMS是基于增量更新来做并发标记的，G1、Shenandoah则是用原始快照来实现

---

**染色指针技术**：  

**背景：** 

追踪式收集算法的标记阶段就可能存在只跟指针打交道而不必涉及指针所引用的对象本身的场景。例如对象标记的过程中需要给对象打上三色标记，这些标记本质上就只和对象的引用有关，而与对象本身无关——某个对象只有它的引用关系能决定它存活与否，对象上其他所有的属性都不能够影响它的存活判定结果。

HotSpot虚拟机的几种收集器有不同的标记实现方案，有的把标记直接记录在对象头上（如Serial收集器），有的把标记记录在与对象相互独立的数据结构上（如G1、Shenandoah使用了一种相当于堆内存的1/64大小的，称为BitMap的结构来记录标记信息），而 **ZGC的染色指针是最直接的、最纯粹的，它直接把标记信息记在引用对象的指针上** 。

**内容：** 

染色指针是一种直接将少量额外的信息存储在指针上的技术。在AMD64架构中只支持到52位（4PB）的地址总线和48位（256TB）的虚拟地址空间，所以目前64位的硬件实际能够支持的最大内存只有256TB。此外，操作系统一侧也还会施加自己的约束，64位的Linux则分别支持47位（128TB）的进程虚拟地址空间和46位（64TB）的物理地址空间，64位的Windows系统甚至只支持44位（16TB）的物理地址空间。

![image-20211202194530161](https://raw.githubusercontent.com/liang636600/cloudImg/master/images/image-20211202194530161.png)

对于linux而言，剩下的46位中将其高4位提取出来存储四个标志信息。通过这些标志位，虚拟机可以直接从指针中看到其引用对象的三色标记状态、是否进入了重分配集（即被移动过）、是否只能通过finalize()方法才能被访问到。缺点是直接导致ZGC能够管理的内存不可以超过4TB（2的42次幂），也不能支持压缩指针（-XX:+UseCompressedOops）

**优点：**

* 染色指针可以使得一旦某个Region的存活对象被移走之后，这个Region立即就能够被释放和重用掉，而不必等待整个堆中所有指向该Region的引用都被修正后才能清理
* 