各种经典收集器的关系如下图

![image-20211205103552223](https://raw.githubusercontent.com/liang636600/cloudImg/master/images/image-20211205103552223.png)

如果两个收集器之间存在连线，说明他们可以搭配使用，这个关系不是一成不变的，由于维护和兼容性测试的成本，在JDK 8时将Serial+CMS、ParNew+Serial Old这两个组合声明为废弃（JEP 173），并在JDK 9中完全取消了这些组合的支持（JEP214）

# Serial收集器

作用于新生代，在它进行垃圾收集时，必须暂停其他所有工作线程，直到它收集结束

![image-20211205104421711](https://raw.githubusercontent.com/liang636600/cloudImg/master/images/image-20211205104421711.png)

对于内存资源受限的环境，它是所有收集器里额外内存消耗（Memory Footprint）最小的

对于单核处理器或处理器核心数较少的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率

Serial收集器对于运行在客户端模式下的虚拟机来说是一个很好的选择

# ParNew收集器

作用于新生代，与作用于老年代的CMS搭配使用，ParNew收集器实质上是Serial收集器的多线程并行版本

![image-20211205105217329](https://raw.githubusercontent.com/liang636600/cloudImg/master/images/image-20211205105217329.png)

ParNew收集器是激活CMS后（使用-XX：+UseConcMarkSweepGC选项）的默认新生代收集器

默认开启的收集线程数与处理器核心数量相同，在处理器核心非常多的环境中，可以使用-XX：ParallelGCThreads参数来限制垃圾收集的线程数

# 并发与并行

* 并行（Parallel）：并行描述的是多条垃圾收集器线程之间的关系，说明同一时间有多条这样的线程在协同工作，通常默认此时用户线程是处于等待状态。

* 并发（Concurrent）：并发描述的是垃圾收集器线程与用户线程之间的关系，说明同一时间垃圾收集器线程与用户线程都在运行。由于用户线程并未被冻结，所以程序仍然能响应服务请求，但由于垃圾收集器线程占用了一部分系统资源，此时应用程序的处理的吞吐量将受到一定影响。

# Parallel Scavenge

作用于新生代，基于标记-复制算法实现的收集器，目标是达到一个可控制的吞吐量（Throughput）。所谓吞吐量就是处理器用于运行用户代码的时间与处理器总消耗时间的比值
$$
throughput=\frac{timeOfUserThread}{timeOfUserThread+timeOfGC}
$$
Parallel Scavenge收集器提供了两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间的-XX：MaxGCPauseMillis参数以及直接设置吞吐量大小的-XX：GCTimeRatio参数（垃圾收集时间占总时间的比率，譬如把此参数设置为19，那允许的最大垃圾收集时间就占总时间的5%（即1/(1+19)），默认值为99，即允许最大1%（即1/(1+99)）的垃圾收集时间）

Parallel Scavenge收集器还有一个参数-XX：+UseAdaptiveSizePolicy值得关注。这是一个开关参数，当这个参数被激活之后，就不需要人工指定新生代的大小（-Xmn）、Eden与Survivor区的比例（-XX：SurvivorRatio）、晋升老年代对象大小（-XX：PretenureSizeThreshold）等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量

垃圾收集停顿时间缩短是以牺牲吞吐量和新生代空间为代价换取的

# Serial Old收集器

作用于老年代，主要是供客户端模式下的HotSpot虚拟机使用，在服务端模式下作为CMS收集器发生失败时的后备预案

![image-20211205112941239](https://raw.githubusercontent.com/liang636600/cloudImg/master/images/image-20211205112941239.png)

# Parallel Old收集器

Parallel Old是Parallel Scavenge收集器的老年代版本，支持多线程并发收集，基于标记-整理算法实现。在注重吞吐量或者处理器资源较为稀缺的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器这个组合

![image-20211205121525197](https://raw.githubusercontent.com/liang636600/cloudImg/master/images/image-20211205121525197.png)

# CMS收集器

作用于老年代，与ParNew搭配使用，首次实现了让垃圾收集线程与用户线程（基本上）同时工作，尽可能缩短垃圾收集时用户线程的停顿时间，基于标记-清除算法实现的，包括四个步骤

1. 初始标记（CMS initial mark）：需要stop the world，标记一下GC roots能直接关联的对象，速度很快

2. 并发标记（CMS concurrent mark）：

   从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行

3. 重新标记（CMS remark），需要stop the world，为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录

4. 并发清除（CMS concurrent sweep）：清理删除掉标记阶段判断的已经死亡的对象，由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的

![image-20211205141554208](https://raw.githubusercontent.com/liang636600/cloudImg/master/images/image-20211205141554208.png)

**缺点：**

1. CMS收集器对处理器资源非常敏感。回收线程并发占用了CPU资源，导致用户程序吞吐量下降。当处理器核心数量不足四个时，CMS对用户程序的影响就可能变得很大。如果应用本来的处理器负载就很高，还要分出一半的运算能力去执行收集器线程，就可能导致用户程序的执行速度忽然大幅降低。

2. CMS收集器无法处理“浮动垃圾”（Floating Garbage），有可能出现“Con-current ModeFailure”失败进而导致另一次完全“Stop The World”的Full GC的产生

   **浮动垃圾：** CMS在并发标记和并发清理阶段，用户线程继续运行，产生新的垃圾对象，但这一部分垃圾对象是出现在标记过程结束以后，CMS无法在当次收集中处理掉它们，只好留待下一次垃圾收集时再清理掉

   **由于在垃圾收集阶段用户线程还需要持续运行，那就还需要预留足够内存空间提供给用户线程使用，因此 CMS收集器不能像其他收集器那样等待到老年代几乎完全被填满了再进行收集，必须预留一部分空间供并发收集时的程序运作使用** 。调高参数-XX：CMSInitiatingOccupancyFraction的值（老年代已使用空间占比）来提高CMS的触发百分比，降低内存回收频率，获取更好的性能。但这又会更容易面临另一种风险：要是CMS运行期间预留的内存无法满足程序分配新对象的需要，就会出现一次“并发失败”（Concurrent Mode Failure），这时候虚拟机将不得不启动后备预案：冻结用户线程的执行，临时启用Serial Old收集器来重新进行老年代的垃圾收集，但这样停顿时间就很长了

3. CMS是一款基于“标记-清除”算法实现的收集器，收集结束时会有大量空间碎片产生。

   解决方案（JDK 9后废弃）：

   * 在CMS收集器不得不进行Full GC时开启内存碎片的合并整理过程，由于这个内存整理必须移动存活对象，（在Shenandoah和ZGC出现前）是无法并发的，空间碎片问题是解决了，但停顿时间又会变长
   * 要求CMS收集器在执行过若干次（数量由参数值决定）不整理空间的Full GC之后，下一次进入Full GC前会先进行碎片整理

# G1收集器

**自我总结：** G1在垃圾回收流程上没有大改变，主要是引入了region的思想，把新生代和老年代打碎成不固定区域的region，这样可以进行局部垃圾回收，同时引入筛选回收的思想，对region进行统计和排序，选出最需要被回收的region集合

**目标：** 在延迟可控的情况下获得尽可能高的吞吐量

开创了收集器 **面向局部收集的设计思路** 和 **基于Region的内存布局形式**

**停顿时间模型：** 能够支持指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间大概率不超过N毫秒这样的目标

**G1思想：** G1可以面向堆内存任何部分来组成回收集（Collection Set，一般简称CSet）进行回收，衡量标准不再是它属于哪个分代，而是哪块内存中存放的垃圾数量最多，回收收益最大，这就是G1收集器的Mixed GC模式

G1认为只要大小超过了一个Region容量一半的对象即可判定为大对象，大对象将放在Humongous区域。每个Region的大小可以通过参数-XX：G1HeapRegionSize设定，取值范围为1MB～32MB，且应为2的N次幂。G1的大多数行为都把Humongous Region作为老年代的一部分来进行看待

![image-20211206103203304](https://raw.githubusercontent.com/liang636600/cloudImg/master/images/image-20211206103203304.png)

新生代和老年代不固定， **以region作为单次回收的最小单元，每次回收的内存空间都是region大小的整数倍，G1收集器去跟踪各个Region里面的垃圾堆积的“价值”大小，价值即回收所获得的空间大小以及回收所需时间的经验值，然后在后台维护一个优先级列表，每次根据用户设定允许的收集停顿时间（使用参数-XX：MaxGCPauseMillis指定，默认值是200毫秒），优先处理回收价值收益最大的那些Region**

**实现G1需要考虑的细节：** 

* Region里面存在的跨Region引用对象如何解决？

  **每个Region都维护有自己的记忆集，这些记忆集会记录下别的Region指向自己的指针，并标记这些指针分别在哪些卡页的范围之内。** G1的记忆集在存储结构的本质上是一种哈希表，Key是别的Region的起始地址，Value是一个集合，里面存储的元素是卡表的索引号。

  **缺点：**

  * 这种“双向”的卡表结构（卡表是“我指向谁”，这种结构还记录了“谁指向我”）比原来的卡表 **实现起来更复杂**
  * 同时由于Region数量比传统收集器的分代数量明显要多得多，因此G1收集器要比其他的传统垃圾收集器有着更高的内存占用负担。根据经验， **G1至少要耗费大约相当于Java堆容量10%至20%的额外内存来维持收集器工作**。

* 在并发标记阶段如何保证收集线程与用户线程互不干扰地运行？

  通过原始快照（SATB）算法来实现（记录用户线程灰色删除白色的引用，最后恢复这部分引用并标注）

* 如何解决用户线程与收集器线程并发时，用户线程产生新对象分配问题？

  G1为每一个Region设计了两个名为TAMS（Top at Mark Start）的指针，把Region中的一部分空间划分出来用于并发回收过程中的新对象分配，并发回收时新分配的对象地址都必须要在这两个指针位置以上，默认这部分区域的对象存活

  **缺点：** 如果内存回收的速度赶不上内存分配的速度，G1收集器也要被迫冻结用户线程执行，导致Full GC而产生长时间“Stop The World”

* 怎样建立起可靠的停顿预测模型？

  在垃圾收集过程中， **G1收集器会记录每个Region的回收耗时、每个Region记忆集里的脏卡数量等各个可测量的步骤花费的成本，并分析得出平均值、标准偏差、置信度等统计信息** 。这里强调的“衰减平均值”是指它会比普通的平均值更容易受到新数据的影响，更准确地代表“最近的”平均状态， **通过这些信息预测现在开始回收的话，由哪些Region组成回收集才可以在不超过期望停顿时间的约束下获得最高的收益**

**G1收集器的运作过程：**

* 初始标记（Initial Marking）：仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TAMS指针的值，让下一阶段用户线程并发运行时，能正确地在可用的Region中分配新对象。这个阶段需要停顿线程，但耗时很短，而且是借用进行Minor GC的时候同步完成的，所以G1收集器在这个阶段实际并没有额外的停顿。

* 并发标记（Concurrent Marking）：从GC Root开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象，这阶段耗时较长，但可与用户程序并发执行。当对象图扫描完成以后，还要重新处理SATB（原始快照）记录下的在并发时有引用变动的对象。

* 最终标记（Final Marking）：对 **用户线程** 做另一个短暂的 **暂停** ，用于处理并发阶段结束后仍遗留下来的最后那少量的SATB记录。

* 筛选回收（Live Data Counting and Evacuation）：负责更新Region的统计数据，对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region构成回收集，然后把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧Region的全部空间。这里的操作涉及存活对象的移动，是必须 **暂停用户线程** ，由多条收集器线程并行完成的。

![image-20211206111855615](https://raw.githubusercontent.com/liang636600/cloudImg/master/images/image-20211206111855615.png)

**优点：**

* 可以由用户指定期望的停顿时间

  但这个时间不能设置得太小，不然收集器筛选回收阶段回收的region数太少，回收速度跟不上分配速度，导致垃圾逐渐积累，通常把期望停顿时间设置为一两百毫秒或者两三百毫秒会是比较合理的

从G1开始， **最先进的垃圾收集器的设计导向都不约而同地变为追求能够应付应用的内存分配速率（Allocation Rate），而不追求一次把整个Java堆全部清理干净** 。这样，应用在分配，同时收集器在收集，只要收集的速度能跟得上对象分配的速度，那一切就能运作得很完美。

**G1与CMS比较：**

* G1不会产生内存空间碎片，而CMS会

* G1内存占用（Footprint）比CMS高

  G1的卡表实现更为复杂，而且堆中每个Region，无论扮演的是新生代还是老年代角色，都必须有一份卡表，这导致G1的记忆集（和其他内存消耗）可能会占整个堆容量的20%乃至更多的内存空间，而CMS的卡表只有唯一一份，而且只需要处理老年代到新生代的引用，反过来则不需要

* G1程序运行时的额外执行负载（Overload）都要比CMS要高

  CMS用写后屏障来更新维护卡表；而G1除了使用写后屏障来进行同样的（由于G1的卡表结构复杂，其实是更烦琐的）卡表维护操作外，为了实现原始快照搜索（SATB）算法，还需要使用写前屏障来跟踪并发时的指针变化情况。

  相比起增量更新算法，原始快照搜索能够减少并发标记和重新标记阶段的消耗，避免CMS那样在最终标记阶段停顿时间过长的缺点，但是在用户程序运行过程中确实会产生由跟踪引用变化带来的额外负担。

  由于G1对写屏障的复杂操作要比CMS消耗更多的运算资源，所以CMS的写屏障实现是直接的同步操作，而G1就不得不将其实现为类似于消息队列的结构，把写前屏障和写后屏障中要做的事情都放到队列里，然后再异步处理

在 **小内存应用上CMS的表现大概率仍然要会优于G1，而在大内存应用上G1则大多能发挥其优势** ，这个优劣势的Java堆容量平衡点通常在6GB至8GB之间

---

下图中浅色阶段表示必须挂起用户线程，深色表示收集器线程与用户线程是并发工作的

![image-20211206150325928](https://raw.githubusercontent.com/liang636600/cloudImg/master/images/image-20211206150325928.png)

CMS与G1在标记阶段后的处理，未能得到妥善的解决，CMS使用标记-清除算法，虽然避免了整理阶段收集器带来的停顿，但是清除算法不论如何优化改进，在设计原理上避免不了空间碎片的产生，随着空间碎片不断淤积最终依然逃不过“Stop TheWorld”的命运。G1虽然可以按更小的粒度进行回收，从而抑制整理阶段出现时间过长的停顿，但毕竟也还是要暂停的。

Shenandoah和ZGC，几乎整个工作过程全部都是并发的，只有初始标记、最终标记这些阶段有短暂的停顿，这部分停顿的时间基本上是固定的，与堆的容量、堆中对象的数量没有正比例关系。实际上，它们都可以在任意可管理的（譬如现在ZGC只能管理4TB以内的堆）堆容量下，实现垃圾收集的停顿都不超过十毫秒这种以前听起来是天方夜谭、匪夷所思的目标。

---

# Shenandoah收集器

**自我总结：** 主要在G1的基础上，使用了并发清除的策略（即并发回收与引用更新），以及使用全局连接矩阵替代region的记忆集

shenandoah是G1的继承者，使用基于Region的堆内存布局，同样有着用于存放大对象的Humongous Region，默认的回收策略也同样是优先处理回收价值最大的Region

**相比G1的不同：**

* 支持并发的整理算法（与用户线程）

* 目前默认不使用分代收集，这是基于工作量上的考虑而将其放到优先级较低的位置上

* 摒弃了在G1中耗费大量内存和计算资源去维护的记忆集，改用名为“连接矩阵”（Connection Matrix）的全局数据结构来记录跨Region的引用关系

  **优点：** 降低了处理跨代指针时的记忆集维护消耗；降低了伪共享问题的发生概率（伪共享：某区域已经标记为脏，再次被标记为脏）

  连接矩阵可以简单理解为一张二维表格，如果Region N有对象指向Region M，就在表格的N行M列中打上一个标记

  ![image-20211206153000675](https://raw.githubusercontent.com/liang636600/cloudImg/master/images/image-20211206153000675.png)

**工作过程：**

1. 初始标记（Initial Marking）：与G1一样，首先标记与GC Roots直接关联的对象，这个阶段仍是 **“Stop The World”** 的，但停顿时间与堆大小无关，只与GC Roots的数量相关
2. 并发标记（Concurrent Marking）：与G1一样，遍历对象图，标记出全部可达的对象，这个阶段是与用户线程一起并发的，时间长短取决于堆中存活对象的数量以及对象图的结构复杂程度
3. 最终标记（Final Marking）：与G1一样，处理剩余的SATB扫描，并在这个阶段统计出回收价值最高的Region，将这些Region构成一组回收集（Collection Set）。最终标记阶段也会 **有一小段短暂的停顿**
4. 并发清理（Concurrent Cleanup）：这个阶段用于清理那些 **整个区域内连一个存活对象都没有找到的Region** （这类Region被称为Immediate Garbage Region）
5. 并发回收（Concurrent Evacuation）：在这个阶段， **Shenandoah要把回收集里面的存活对象先复制一份到其他未被使用的Region之中** 。 **困难是在移动对象的同时，用户线程仍然可能不停对被移动的对象进行读写访问，移动对象是一次性的行为，但移动之后整个内存中所有指向该对象的引用都还是旧对象的地址，这是很难一瞬间全部改变过来的** 。对于并发回收阶段遇到的这些困难，Shenandoah将会通过读屏障和被称为“Brooks Pointers”的转发指针来解决。并发回收阶段运行的时间长短取决于回收集的大小。
6. 初始引用更新（Initial Update Reference）：并发回收阶段复制对象结束后，还需要把 **堆中所有指向旧对象的引用修正到复制后的新地址，这个操作称为引用更新** 。引用更新的初始化阶段实际上 **并未做什么具体的处理** ，设立这个阶段只是 **为了建立一个线程集合点，确保所有并发回收阶段中进行的收集器线程都已完成分配给它们的对象移动任务而已** 。初始引用更新时间很短， **会产生一个非常短暂的停顿** 。
7. 并发引用更新（Concurrent Update Reference）：真正开始进行引用更新操作，这个阶段是与用户线程一起并发的，时间长短取决于内存中涉及的引用数量的多少。并发引用更新与并发标记不同，它不再需要沿着对象图来搜索，**只需要按照内存物理地址的顺序，线性地搜索出引用类型，把旧值改为新值即可** 。
8. 最终引用更新（Final Update Reference）：解决了堆中的引用更新后，还要 **修正存在于GC Roots中的引用** 。这个阶段是Shenandoah的最后一次 **停顿** ，停顿时间只与GC Roots的数量相关
9. 并发清理（Concurrent Cleanup）：经过并发回收和引用更新之后，整个回收集中所有的Region已再无存活对象，这些Region都变成Immediate Garbage Regions了，最后再调用一次并发清理过程来回收这些Region的内存空间，供以后新对象分配使用

主要是三个阶段，标记，回收，引用更新

| 标记     | 回收                                                         | 引用更新                                       |
| -------- | ------------------------------------------------------------ | ---------------------------------------------- |
| 初始标记 | 并发清理（整个region无存活对象）                             | 初始引用更新（保证收集器线程完成对象移动任务） |
| 并发标记 | 并发回收（把collection set中的存活对象移动到空闲region中）   | 并发引用更新（更新引用的旧值为新值）           |
| 最终标记 | 并发清理（清理掉已完成存活对象移动的collection set中的region） |                                                |

![image-20211206160628431](https://raw.githubusercontent.com/liang636600/cloudImg/master/images/image-20211206160628431.png)

黄色的区域代表的是被选入回收集的Region，绿色部分就代表还存活的对象，蓝色就是用户线程可以用来分配对象的内存Region了。

**对象移动与用户程序并发的解决方案：**

* 不建议使用：**在被移动对象原有的内存上设置保护陷阱（Memory Protection Trap），一旦用户程序访问到归属于旧对象的内存空间就会产生自陷中断，进入预设好的异常处理器中，再由其中的代码逻辑把访问转发到复制后的新对象上** 。虽然确实能够实现对象移动与用户线程并发，但是如果没有操作系统层面的直接支持，这种方案将导致用户态频繁切换到核心态，代价是非常大的，不能频繁使用

* 使用转发指针（Forwarding Pointer，也常被称为Indirection Pointer）：在原有对象布局结构的最前面统一增加一个新的引用字段，在正常不处于并发移动的情况下，该引用指向对象自己

  ![image-20211206195214781](https://raw.githubusercontent.com/liang636600/cloudImg/master/images/image-20211206195214781.png)

  **原理：** 对象有一个转发指针，当对象有了一个新的副本时，旧地址的对象的转发指针指向该对象的新副本地址，只要旧对象的内存仍然存在，未被清理掉，虚拟机内存中所有通过旧引用地址访问的代码便仍然可用，都会被自动转发到新对象上继续工作

  ![image-20211206200620980](https://raw.githubusercontent.com/liang636600/cloudImg/master/images/image-20211206200620980.png)

  **缺点：** 

  * 每次对象访问会带来一次额外的转向开销

  * 会出现多线程竞争问题

    例如：1）收集器线程复制了新的对象副本；2）用户线程更新对象的某个字段；3）收集器线程更新转发指针的引用值为新副本地址。

    **解决：** 让收集器线程或者用户线程对转发指针的访问只有其中之一能够成功，另外一个必须等待，避免两者交替进行（通过CAS实现）

  * 使用读屏障带来了性能开销

    **解决：** 将Shenandoah的内存屏障模型改进为基于引用访问屏障（Load Reference Barrier）的实现，所谓 **“引用访问屏障”是指内存屏障只拦截对象中数据类型为引用类型的读写操作，而不去管原生数据类型等其他非引用字段的读写** ，这能够省去大量对原生类型、对象比较、对象加锁等场景中设置内存屏障所带来的消耗

![image-20211206202507049](https://raw.githubusercontent.com/liang636600/cloudImg/master/images/image-20211206202507049.png)
