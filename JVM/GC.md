在Java技术体系里面，固定可作为GC Roots的对象包括以下几种：

* 在虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。

* 在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量。

* 在方法区中常量引用的对象，譬如字符串常量池（String Table）里的引用。

* 在本地方法栈中JNI（即通常所说的Native方法）引用的对象

* Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如NullPointExcepiton、OutOfMemoryError）等，还有系统类加载器

* 所有被同步锁（synchronized关键字）持有的对象

* 反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等

# 分代收集理论

**跨代引用假说（Intergenerational Reference Hypothesis）：** 跨代引用相对于同代引用来说仅占极少数。如果是年轻代指向老年代的引用我们不用关心，因为即使Minor GC把年轻代的对象清理掉了，程序依然能正常运行，而且随着引用链的断掉，无法被标记到的老年代对象会被后续的Major GC回收。如果是老年代指向年轻代的引用，那这个引用在Minor GC阶段是不能被回收掉的，那如何解决这个问题呢？

最简单的实现方式当然是每个对象中记录这个跨Region引用记录，GC时扫描所有老年代的对象，显然这是一个相当大的Overhead。

最合理的实现方式只需在新生代上建立一个全局的数据结构（该结构被称为“记忆集”，Remembered Set），这个结构把老年代划分成若干小块，标识出老年代的哪一块内存会存在跨代引用。此后当发生Minor GC时，只有包含了跨代引用的小块内存里的对象才会被加入到GCRoots进行扫描。

## 记忆集和卡表

