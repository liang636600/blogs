# 面向大数据处理框架的JVM优化技术综述

## 摘要：

1. 总结了大数据应用在JVM中运行时性能下降的原因; 
2. 总结了现有面向大数据处理框架的JVM优化技术,对相关优化技术进行了层次划分,并分析比较了各种方法的优化效果、适用范围、使用负担等优缺点; 
3. 探讨了JVM未来的优化方向,有助于进一步提升大数据处理框架的性能

## 1 相关背景概述

**JVM相关性能瓶颈：**

* 最主要来自JVM长时间,高频次的GC
* 分布式节点间的网络传输需要JVM序列化和反序列化数据对象
* JVM冷启动的预热用时
* JVM内存溢出错误

**面向大数据处理框架的JVM优化技术：**

* 大数据框架的内存管理
* JVM中数据对象的存储方法
* JVM的GC算法
* JVM集群的协同
* JVM在新型硬件架构中的应用

### 1.1 大数据处理框架的工作流程

**简单表示为：**

Map阶段: map<K1,V1> => list<K2,V2>

混洗(Shuffle)阶段: list<K2,V2> => <K2,list(V2)>

Reduce阶段: reduce<K2,list(V2)> => list<K3,V3>

![image-20211111101512144](https://raw.githubusercontent.com/liang636600/cloudImg/master/images/image-20211111101512144.png)

大数据应用通常以<输入数据,用户代码,配置参数>的形式提交给大数据处理框架。框架得到用户输入，生成一个 **驱动器(Driver)程序** ,将应用分解为多个作业(jobs)。job被划分为多个stage,每个stage被分为多个task。task经由任务调度系统,分配到集群的节点上,以JVM进程（Hadoop）或者线程（Spark）的方式运行。输入数据转换为数据对象，由jvm管理。

### 1.2 JVM的运行过程

JVM发现某部分代码运行频繁,就把热点代码即时编译(JIT)为本地机器码,提高代码后续的执行效率。

**JVM初始化的冷启动消耗：** 类加载和热点代码的即时编译过程

**JVM的运行时数据内存** 包括每个JAVA线程私有的程序计数器,虚拟机栈,和本地方法栈,以及所有线程共享的方法区和堆内存。堆内存用于存储 **所有的对象实例** 以及 **数组**。

### 1.3 JVM垃圾回收机制

gc算法通过可达性分析（深度优先算法向下扫描）判断对象存活

**GC Roots根对象集：** 虚拟机栈中引用的对象,方法区中类静态属性引用的对象,本地方法栈中引用的对象等

GC流程的扫描和移动任务通常都被添加到**GC任务队列** 中,由GC线程从任务队列中获取和执行

**Parallel GC** 允许多个GC线程同时从GC任务队列中获取任务并行执行

**G1采用基于区域的堆内存划分方法** ，每次GC只处理其中一部分区域，解决了Full GC处理量大，全局暂停时间过长的问题。区域可以不固定划分为伊甸园区，幸存者区，老年区。当老年代区域存活对象低于一定的阈值时，该区域加入待GC区域集，当待GC区域集达到一定比例的时候触发混合GC（Mixed GC），收集待GC老年区和所有年轻代区。G1通过记忆集（Remember Set）快速处理区域间的引用关系,通过堆快照(Snapshot)和写屏障(Write Barrier),使得G1可以在部分处理阶段实现工作线程和GC线程并发执行,达到降低全局暂停时间的目的

## 2 JVM在大数据环境中存在的问题及原因分析

### 2.1 JVM在大数据环境中的性能问题

**JVM的执行效率是大数据处理框架的重要性能瓶颈,其中GC机制是对JVM执行效率影响最大的因素**

### 2.2 原因1: 内存使用压力增大

* 大数据应用数据计算和存储
* 在JVM堆内存当中以对象的形式存储需要的额外内存占用

### 2.3 原因2: 内存使用模式变化

大数据应用两种对象类型：

1. 控制大数据处理框架运行逻辑的代码产生的,称为 **控制路径对象** （通常符合弱世代假设）
2. 输入数据和计算中间数据在大数据处理框架中封装产生的,统称为 **数据路径对象**

在代码数量上控制路径比数据路径多,但数据路径所创建的对象数量和存活时间远超控制路径

传统GC算法不能适应这种模式，原因：

1. **对象在内存中移动耗时：** 大量数据路径对象从新生代到老年代需要在内存中多次移动，
2. 在Major GC或Mixed GC前对数据路径对象的标记耗时不必要

### 2.4 原因3: JVM与上层框架存在隔阂

在各节点运行的JVM具有很高的自主性，从全局的角度看不一定是最优的

* JVM不适应大数据中的对象，这些对象本可以通过大数据框架对用户代码和数据流的全局静态分析进行甄别
* 大数据倾向连续地址空间，JVM目前是非连续空间。由于大数据连续地址空间可能产生跨节点对象引用，带了远程访问负担
* 大数据如果执行在不同JVM之间的同步的时候可能会由于不同JVM的GC时间不同而遭打断，同时这样也缺乏统筹协调，可能导致同一节点的JVM内存资源分配不合理

## 3 面向大数据处理框架的JVM优化技术概览

![img](https://raw.githubusercontent.com/liang636600/cloudImg/master/images/wpsFE5E.tmp.jpg)

大数据处理框架可以划分为3个层次:用户层,大数据框架层,运行时环境层。

**流程：** 用户层将应用代码和应用执行参数提交给大数据框架层,将应用资源需求参数提交给运行时环境层.

大数据框架层构建出应用的逻辑处理流程和分布式的物理执行计划,并根据集群节点的资源使用情况,将任务调度到各个机器节点的JVM上执行.

JVM所在的运行时环境层,根据应用资源需求参数,获得相应的CPU和内存等硬件资源,具体执行计算任务

**从应用层优化：** 对应用执行参数和应用资源需求参数进行调优(Tuning)。基于白盒的调优工具（在假设分析模型的创建存在挑战）与基于黑盒的调优工具（耗时）。参数调优针对固定硬件环境下的一种大数据应用。

**在用户层的参数调优并不能从本质上改善JVM在大数据处理框架下的适应性问题**。

**从大数据框架层和运行时环境层优化：**

![image-20211111170548889](https://raw.githubusercontent.com/liang636600/cloudImg/master/images/image-20211111170548889.png)

## 4 大数据框架的内存管理优化

**大数据框架的内存管理优化技术分类：**

| **优化技术**                     | **针对问题**                                    | **实现方法**                                               |
| -------------------------------- | ----------------------------------------------- | ---------------------------------------------------------- |
| 大数据框架内存分配参数的动态调整 | 大数据框架默认的内存用途分配固定而非最优        | 根据应用在运行时的执行情况动态调节大数据框架的内存分配比例 |
| 基于生命周期的大数据框架对象管理 | 执行器JVM在处理大量不同生命周期对象时的效率低下 | 根据对象在大数据框架中的用途和使用阶段确定对象的生命周期   |

### 4.1 优化技术1: 大数据框架内存分配参数的动态调整

**核心：** 在运行时，收集相关信息，动态调整内存分配参数（例如堆大小和spark存储空间）

大数据处理框架在task执行过程中统计和估算存活对象在JVM堆内存中占据的大小,并将每种对象占用的内存总大小控制在一定参数阈值之内。

例如：Spark在1.6版本之前的默认情况下,将执行器JVM堆内存的90%划分为安全空间,将其余10%用于任务处理.安全空间进一步被划分用于RDD缓存、混洗操作,和RDD的序列化/反序列化展开.如果Spark统计估算剩余的存储空间大小不足以继续缓存RDD,就会通过一定的策略换出部分RDD到磁盘当中,严格保证用于RDD缓存的内存大小不超过相关参数决定的阈值。

默认的内存分配参数值对特定应用而言往往不是最佳，确定某一应用在特定机器环境下的最佳参数配置耗时且繁琐，并且同一应用在不同阶段对内存的需求类型也不同，很难通过静态参数设置达到很好的效果。

**执行过程中动态调整配置参数：** 

**MEMTUNE提出** 在每个执行器上运行一个监视器，收集GC时间,内存交换,任务执行时间等运行信息，传递给主节点上的控制器，由控制器动态做出内存分配比例的调整。最初执行器JVM启动时，JVM堆大小和用于RDD缓存的Spark存储空间比例都被设置为最大。MEMTUNE根据当前GC比率和内存交换比率，判断当前执行阶段是否存在任务执行内存短缺或是混洗内存短缺。如果**混洗内存短缺** ,控制器则降低JVM堆内存大小和存储空间比例,给予混洗空间和堆外的I/O缓冲区更大空间。如果**执行内存短缺** ,控制器则增大JVM堆内存或是降低存储空间比例,保证有足够内存用于任务执行。否则,控制器就提供尽可能大的内存空间用于缓存RDD。

**Spark1.6** 开始统一内存管理,允许用于RDD缓存和用于混洗的内存空间相互借用,实现大数据处理框架内存分配参数的动态调整.

### 4.2 优化技术2: 基于生命周期的大数据框架对象管理

**核心思想**：

* **方式一：通过确定对象的生命周期，将生命周期类似的聚合在一起，然后一同释放空间。**
* **方式二：在内存紧张的情况下，通过确定对象在将要到来的阶段是否会使用来确定对象是否会被置换**

执行器JVM不能感知对象的生命周期，但大数据框架可以。大数据框架可以将生命周期相近的聚合管理，协助执行器JVM垃圾回收。

Deca根据生命周期将 **Spark** 中用户定义类型的对象分为3种类别: **用户定义函数变量、缓存RDD、混洗缓冲对象** 。对于同一类型的对象，如果能够通过分析确定它在运行时大小不会发生变化，那么将其数值分解出来，放入字节数组的容器中（在JVM中）统一管理，这样可以对同一类型的对象一同释放和回收。**缓存RDD容器** 的生命周期可以显示地由cache()函数和unpersist()函数确定。**混洗缓冲容器** 则在混洗数据被读取完毕后生命结束。**用户定义函数变量容器** 结束于任务结束时,其中大部分对象可以被认为是短寿命对象,可以直接当做普通对象由执行器JVM直接处理。

**Flink** 将执行器JVM堆内存的大部分空间以字节数组的形式划分为内存段,用于聚合存储对象的数据值,在一个任务管理器关闭时集中释放。

大数据框架在运行应用代码前，会根据代码构建隐式或显式的数据流操作符图，这些图可以指示部分对象的生命周期。

**Spark** 中RDD的生命周期信息也被用于制定相应的缓存换出策略。利用有向无环图确定RDD块的生命周期，将一个处理阶段被引用的RDD块列入热表，已完成任务的RDD块列入完成表。当划分给RDD缓存的内存不足，扫描所有已缓存的RDD块,优先换出不在热表中的块和完成表中的块。若没有符合条件的RDD块，优先换出分区数量大的(Spark优先执行分区数量小的块,因而换出的块短期不会被执行)

### 4.3 小结

缺点：

* 缺乏通用性
* 对象的生命周期感知不准确

## 5 执行器集群的协同优化

每个执行器JVM有很强的的自主性，在整个集群看来并非最优，大数据框架对执行器JVM优化只能通过启动时配置参数优化

JVM集群的协同优化技术分类

| **优化技术**                     | **针对问题**                                         | **实现方法**                                        |
| -------------------------------- | ---------------------------------------------------- | --------------------------------------------------- |
| 基于全局协调的执行器GC时机决策   | 不同执行器JVM交错的GC暂停影响全局进度                | 根据全局监控信息协调所有执行器JVM在同一时间统一GC   |
| 基于历史的执行器JVM重用          | JVM冷启动用时在大数据应用执行总时间中的占比较大      | 在作业完成后保留执行器JVM,执行新作业时匹配JVM重用   |
| 基于动态规划的执行器内存弹性分配 | 大数据框架无法在执行器启动时准确预估任务所需内存大小 | 根据执行器JVM增加堆内存的价值和GC的代价决定内存分配 |

### 5.1 优化技术1: 基于全局协调的执行器GC时机决策

**核心：** 不同节点的JVM协调执行某个工作，但可能会存在某个JVM在这个时候GC（其他JVM空等），因此全局统一不同JVM的GC时间

不同执行器JVM交错的GC暂停影响全局进度

根据全局监控信息协调所有执行器JVM在同一时间统一GC

**背景：** 执行器JVM在混洗阶段或者一个迭代的超步结束之后,需要互相交换数据,且只能在所有交换完成之后才能整体向下执行,类似于一个全局屏障。 **不同的执行器JVM可能在这个阶段执行GC操作（其他节点空等GC完成），可能造成该过程被频繁的GC打断** 。

**策略：** 实现一个跨节点运行的整体运行时系统，在一个执行器JVM进行GC时，其余执行器JVM也进行GC（由于不同执行器JVM的任务相似，因此GC时机也相似）

**缺陷：**

* 对于延迟敏感的数据库请求不能满足要求，这种应该尽量避免GC
* 不同应用的不同阶段对执行器GC决策方法有不同期望,依赖用户编写和调整全局的GC策略过于繁琐

### 5.2 优化技术2:基于历史的执行器JVM重用

**核心：** 对于任务量小、类型不多且过程相似的大数据应用而言，JVM冷启动耗时较长，因此保留历史JVM组成JVM池，新到的任务可以找到最匹配的JVM（不用冷启动）

JVM冷启动用时在大数据应用执行总时间中的占比较大

在作业完成后保留执行器JVM,执行新作业时匹配JVM重用

**背景：** 冷启动包括类加载和代码即时编译，对于任务量小的短任务并不划算。提前将字节码部分或全部编译为机器码，避免每个JVM在预热时重复编译，但同时会使JVM失去以配置为导向进行动态优化的好处。尝试延长执行器JVM运行时间，减少冷启动JVM次数。

**策略：** 对执行过作业的JVM建立JVM池，以后新来作业，在JVM池中选择以前执行过与该作业最相似的JVM（如果JVM池中JVM都在工作，则fork一个），这样减少了冷启动JVM次数，适合用于延迟敏感的大数据应用如查询事务（类型有限并且重复度较高，需要加载的类和编译的热点代码是高度一致）

**缺陷：** 

* 重用方法不能保证正确和一致，许多静态数据在运行前需要重新初始化
* 只适用于连续执行相同类型大数据应用的场景,否则维持大量JVM也需要内存消耗,对内存紧张的应用场景并不友好

### 5.3 优化技术3:基于动态规划的执行器内存弹性分配

**核心：** 协调同一个节点不同执行器JVM内存，利用背包问题模型进行动态规划选择操作

大数据框架无法在执行器启动时准确预估任务所需内存大小

根据执行器JVM增加堆内存的价值和GC的代价决定内存分配

**背景：** 执行器JVM拥有内存资源是由资源管理器根据大数据框架的预估值进行调度和分配,但任务使用的内存受很多运行时因素影响难以准确估计。动态规划位于同一机器节点上执行器JVM的内存分配,最大化利用物理内存资源

**策略：** 动态规划同一机器节点上各个执行器JVM的内存分配。对Parallel GC修改，将最大可用堆内存大小设置的足够大,用老年代和年轻代的大小限制来控制实际的内存使用量,并提供了调整堆内存大小,外部触发GC,获取堆状态信息的接口。在 **执行器JVM没有可用内存时的可操作选项分为5个** :调整堆大小、触发Young GC、触发Parallel原生Full GC(先进行Young GC晋升,再收集老年代)、触发改进版的Full GC(直接对整个堆内存收集)、空置等待、终止JVM进程。为每种操作都设计了对应的代价计算方法,代价越小则价值越高。空置等待、终止JVM进程尽量不被选择。 **具体的代价数值的计算** 依赖于 **机器学习** 模型对于JVM中存活和死亡对象数量的预测,以及对于进行GC用时的预测。对每个执行器JVM的 **具体选择利用背包问题模型进行动态规划** ,为了降低算法复杂度,堆内存大小的调整尺度被设置为粗粒度的块,或是一定比例的剩余物理内存

**缺陷：**

* 动态协调执行器JVM内存分配的规划算法复杂度较高,预测模型需要提前训练且可移植性有限

### 5.4 小结

## 6 JVM中数据对象的存储方法优化

JVM中数据对象存储方法的优化技术分类

| **优化技术**                   | **针对问题**                                   | **实现方法**                                              |
| ------------------------------ | ---------------------------------------------- | --------------------------------------------------------- |
| 基于区域的数据对象存储和处理   | 数据对象和传统对象生命周期的差异影响GC算法效率 | 在专门的内存区域存储和管理数据对象,减轻GC算法工作量       |
| 基于二进制的数据对象序列化存储 | 以对象的形式存储数据内存利用率较低,GC负担较重  | 将数据对象序列化为二进制的形式,算法直接对二进制数据值操作 |

数据对象是影响执行器JVM内存管理效率的主要因素，一些研究工作对数据对象采取集中的存储和处理，一些研究工作用二进制的形式来存储数据值

### 6.1 优化技术1: 基于区域的数据对象存储和处理

数据对象和传统对象生命周期的差异影响GC算法效率

在专门的内存区域存储和管理数据对象,减轻GC算法工作量

**核心：** 执行器JVM可以在特定的内存区域中集中存储数据对象,并在恰当的时机直接清理相应内存区域

**策略：** 

* 将JVM堆空间分为 **控制空间和数据空间，修改原始GC算法使其不扫描数据空间** 。开发者需要标注纪元（epoch）的开始和结束，系统遇到纪元开始标志则创建一个区域，在纪元结束前，所有数据对象都放在这个区域中，当出现纪元结束时，清空对应区域。并且纪元区域支持嵌套，存活时间长的对象被放在最外层纪元区域中，但每个对象为实现晋升使用了四个字节增加了存储空间占用

* FACADE在 **堆外存储数据对象的数据值，在堆内存储操作数据值的简化对象** ，要求开发者标注出所有数据路径的类，创建相应数量的简化对象，形成简化对象池。同时要求开发者标出迭代开始和结束位置，在迭代结束时直接清除掉堆外数据存储空间
* **大数据框架的主要数据结构类在JVM堆内存中创建一块连续的区域,用于单独存储属于这个类的数据对象**. 要求开发者标注出主要数据结构类,创建对应数据对象节点的集中存储区域，同时标记出每一个节点从数据结构中被删除的位置,以确定在每次GC触发时具体存活的数据对象。在GC时，直接将数据结构区域中存活的节点标记为存活并放入到GC root中。由于数据结构区域连续占用内存，这样可以减少TLB缺页次数。但如果开发者没能准确地标注出所有节点的增删,将会直接触发Full GC,带来性能损失
* **Flink以及Spark的Tungsten** 内存管理器,都以 **字节数组的形式集中连续存储用于操作的数据对象值**

### 6.2 优化技术2: 基于二进制的数据对象序列化存储

**核心：** 将数据对象以二进制的形式进行压缩

以对象的形式存储数据内存利用率较低,GC负担较重

将数据对象序列化为二进制的形式,算法直接对二进制数据值操作

大数据处理框架下的数据都以对象的形式存在执行器JVM当中,对象头以及对象引用占用了大量内存空间,将数据对象以二进制的形式进行压缩

**策略：**

* 开发人员将相同类型的数据以二进制的形式存在一个大对象中。这样可以减少数据全以对象格式存储的对象外壳开销，同类型的数据一般也有着相似的生命周期。
* 在堆外内存页中存储二进制的数据对象值，在编译器层面实现了二进制数据值的存取,通过重新编译应用程序的JAVA字节码,自动化完成数据值在堆外内存的二进制存储
* Deca的数据存储容器同样以字节数组的形式存储数据
* Spark的内存管理器Tungsten直接以二进制形式存储和操作数据
* Flink通过内存段实现对堆外内存以及堆内内存直接管理,由定制化的序列化工具将绝大部分数据类型对象高效序列化,并实现了二进制数据的直接操作
* Gerenuk以二进制的形式在网络传输和内存中表示数据，基于绝大部分的数据对象在执行过程中是数值不变且大小受限的。在序列化与反序列化中间，找到被引用的数据类，然后创建这些数据对象的时候直接在内存中保存数据值，如果碰到不满足假设条件的数据，重启一个JVM执行器对数据反序列化，再执行原任务代码。

**优点：**

* 提高内存利用效率
* 降低GC算法工作负担
* 节省网络传输中序列化与反序列化的开销

### 6.3 小结

**缺点：** 对开发者要求高，增加开发者负担

## 7 JVM的GC算法优化

JVM的GC算法优化技术分类

| **优化技术**                | **针对问题**                                    | **实现方法**                                              |
| --------------------------- | ----------------------------------------------- | --------------------------------------------------------- |
| 基于Parallel GC的并行度优化 | Parallel GC在多核环境下不能充分利用CPU资源      | 在CPU核之间平衡GC任务负载,或将闲置CPU核用于应用线程       |
| 基于G1 GC的年代划分数量拓展 | 不同生命周期对象没有区分,增加长寿对象的移动次数 | 拓展G1年代到多年代,将生命周期相近的对象申请到相同年代区域 |

### 7.1 优化技术1: 基于Parallel GC的并行度优化

**核心：** 在CPU核之间平衡GC任务负载,解决区域依赖，解决重复计算问题,或将闲置CPU核用于应用线程

Parallel GC在多核环境下不能充分利用CPU资源

在CPU核之间平衡GC任务负载,或将闲置CPU核用于应用线程

Parallel GC算法的 **设计初衷** 是在全局暂停时,JVM能够多线程并行地从GC任务队列当中获取和执行GC任务,达到加快处理速度,降低全局暂停时间的目的，但在多核环境中的可拓展性并不能达到预期

**背景1：**

**Parallel GC在GC线程和CPU核之间的负载不均是影响Parallel GC并行度的重要因素** ，绝大部分GC任务都是由个别GC线程完成的,且这些GC线程都是由个别CPU核完成的，主要由于Linux采用定期平衡,时间粒度过大超过正常GC执行时间。由于GC任务不合理的锁竞争，GC任务总是由个别GC线程取得的。

Parallel GC设计了 **任务窃取机制** 来平衡GC线程之间的负载，但不起效。

**策略1：**

Suo等人的优化工作协助操作系统,将GC线程平衡到各个CPU核上；记录还有GC任务的GC线程作为任务窃取对象

**背景2：**

Scissor将Parallel GC在线程之间并行程度较低的问题归咎于 **区域依赖** 。GC线程在整理阶段将源区域的存活对象拷贝到线程自身负责的区域，然而当一个GC线程负责的区域还有存活对象没有被其他GC线程复制时,该GC线程不能在这个区域开始工作，区域依赖和连锁的区域依赖现象普遍出现,大部分GC线程在自身负责的区域中不能找到一块完全“干净”的区域展开工作,只能阻塞等待依赖的区域先被少数GC线程清理干净。

**策略2：**

在GC线程处理到非空区域时,先申请一个 **影子区域** 用于拷贝源区域的存活对象,而当负责区域的存活对象都被处理干净之后,再将影子区域的对象拷贝回来。对于存活对象占比很大的稠密区域,Scissor选择了不移动。

**背景3：**

Parallel GC在对象移动和拷贝中还存在的另一个问题是引用更新时的 **重复计算** 。Parallel GC在计算存活对象的新地址时,需要累加源区域在当前对象之前所有存活对象的大小,这个工作是重复且不必要的。

**策略3：**

在每个GC线程中 **保留上一次处理的源区域信息** ,包括其存活对象累加大小,如果GC线程处理的下一个对象仍在同一源区域中,则可以根据上次保留的结果,直接计算得到当前对象的新地址

### 7.2 优化技术2: 基于G1 GC的年代划分数量拓展

**核心：** 清楚对象的生命周期

不同生命周期对象没有区分,增加长寿对象的移动次数

拓展G1年代到多年代,将生命周期相近的对象申请到相同年代区域

**背景：**

传统的年代划分，不能有效降低长时间存活对象的拷贝次数

**策略：**

* NG2C将G1 GC拓展到N个代，并将寿命预期相近的对象申请在同一年代的区域当中，要求开发者对对象生命周期做出注释
* POLM2根据运行时信息自动地预测对象的生命周期,并直接在应用程序的字节码上进行注释（注释完后利用NG2C），基于对象申请时的函数调用状态和代码位置信息来区分不同类型对象
* ROLP对经过JIT即时编译的汇编代码进行类似操作,并将生命周期预测结果作为注释传递给NG2C

### 7.3 小结

## 8 新型硬件架构下的JVM优化

新型硬件架构下的JVM优化技术分类

| **优化技术**                          | **针对问题**                                                 | **实现方法**                                              |
| ------------------------------------- | ------------------------------------------------------------ | --------------------------------------------------------- |
| 基于内存分解架构的执行器JVM数据本地化 | 大数据框架下对象的空间局部性差,影响GC算法在资源分解架构上的性能 | 将大部分对象的管理工作交给距离更近的处理器,提高空间局部性 |
| 基于NVM的执行器JVM内存拓展            | 仅使用DRAM的JVM在大数据框架下内存空间紧张,且数据宕机易失.    | 使用NVM和DRAM混合的JVM堆内存空间,缓解使用压力,提供持久化  |

### 8.1 优化技术1: 基于内存分解架构的执行器JVM数据本地化

**核心：** 解决对象离散地分布在各节点中，空间局部性不高的问题

大数据框架下对象的空间局部性差,影响GC算法在资源分解架构上的性能

将大部分对象的管理工作交给距离更近的处理器,提高空间局部性

**背景：**

对象离散地分布在各节点中，空间局部性不高

**策略：**

* Semeru提出了一种分布式JVM，将所有的内存资源组成一个全局的JVM堆空间,统一了 **内存服务器和CPU服务器** 中的内存地址空间,其中每个内存服务器负责管理一段内存,采用和G1 GC类似的基于区域的管理
* NumaGiC使得GC线程可以根据地址信息获知对象所在节点位置,并能够将对象放置在期望的节点之上，要求应用线程在内存申请时就在本地申请，GC线程只扫描 **所在节点的GC根对象** ，在对象整理阶段 **将所有存活对象移动到GC线程所在的节点** 

### 8.2 优化技术2: 基于NVM的执行器JVM内存拓展

仅使用DRAM的JVM在大数据框架下内存空间紧张,且数据宕机易失

使用NVM和DRAM混合的JVM堆内存空间,缓解使用压力,提供持久化

* Panthera将NVM加入到大数据处理框架的内存环境之中,为Spark提供更多的RDD缓存空间
* NVM的持久化特性被运用在大数据处理框架的故障恢复当中

### 8.3 小结

**缺点：**

对硬件环境的针对性很强,大都无法工作在常规硬件环境当中,部分工作面向的大数据处理框架类型也较为单一

## 9 总结及未来展望

1. 大数据框架层面

   框架接手一部分JVM内存管理工作或开发对GC和CPU缓存友好的基础算子

2. JVM的GC算法

   引入机器学习

3. JVM的冷启动预热

4. JVM数据对象转换的序列化和反序列化
