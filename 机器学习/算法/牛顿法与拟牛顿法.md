![image-20220605090341200](https://raw.githubusercontent.com/liang636600/cloudImg/master/images/image-20220605090341200.png)

# 1 牛顿法

## 应用：求方程的近似解

![image-20220603203505582](https://raw.githubusercontent.com/liang636600/cloudImg/master/images/image-20220603203505582.png)

计算f(x)=0的解
$$
x_{k+1}=x_{k}-\frac{f(x_{k})}{{f}'(x_{k})}
$$
选择一个初始值x0，根据上面公式迭代获得x1，一直迭代，直到满足精度（例如abs( x(n+1)-xn)<ε ）或达到最大迭代次数

## 原理

### 一元函数

![image-20220604174609634](https://raw.githubusercontent.com/liang636600/cloudImg/master/images/image-20220604174609634.png)

![image-20220604174733684](https://raw.githubusercontent.com/liang636600/cloudImg/master/images/image-20220604174733684.png)

代码实现

![image-20220604174943282](https://raw.githubusercontent.com/liang636600/cloudImg/master/images/image-20220604174943282.png)

![image-20220604175134463](https://raw.githubusercontent.com/liang636600/cloudImg/master/images/image-20220604175134463.png)

**使用条件：**起始点足够接近极小点

对于凸函数而言

![image-20220603205539182](https://raw.githubusercontent.com/liang636600/cloudImg/master/images/image-20220603205539182.png)

### 多元函数

![image-20220604213954223](https://raw.githubusercontent.com/liang636600/cloudImg/master/images/image-20220604213954223.png)

![image-20220604214824376](https://raw.githubusercontent.com/liang636600/cloudImg/master/images/image-20220604214824376.png)

代码

![image-20220604215217519](https://raw.githubusercontent.com/liang636600/cloudImg/master/images/image-20220604215217519.png)

![image-20220604215127792](https://raw.githubusercontent.com/liang636600/cloudImg/master/images/image-20220604215127792.png)

### 缺点

![image-20220604215338793](https://raw.githubusercontent.com/liang636600/cloudImg/master/images/image-20220604215338793.png)

![image-20220604215827046](https://raw.githubusercontent.com/liang636600/cloudImg/master/images/image-20220604215827046.png)

## 应用：求凸函数的极小值

![image-20220603210753718](https://raw.githubusercontent.com/liang636600/cloudImg/master/images/image-20220603210753718.png)

# 2 割线法

差分近似微分，即
$$
{f}''(a_{k})=\frac{{f}'(a_{k})-{f}'(a_{k-1})}{a_{k}-a_{k-1}}
$$
然后迭代的式子变为下面

![image-20220604175924319](https://raw.githubusercontent.com/liang636600/cloudImg/master/images/image-20220604175924319.png)

代码实现

![image-20220604180115281](https://raw.githubusercontent.com/liang636600/cloudImg/master/images/image-20220604180115281.png)

# 3 修正牛顿法（Levenberg-Marquardt）

存在计算量巨大的缺点

## 解决不能保证目标函数值下降问题

![image-20220604221350403](https://raw.githubusercontent.com/liang636600/cloudImg/master/images/image-20220604221350403.png)

其中α值的确定

![image-20220604221508138](https://raw.githubusercontent.com/liang636600/cloudImg/master/images/image-20220604221508138.png)

搜索更新的代码



![image-20220604221547728](https://raw.githubusercontent.com/liang636600/cloudImg/master/images/image-20220604221547728.png)

## 解决非正定黑塞矩阵问题

![image-20220604222117494](https://raw.githubusercontent.com/liang636600/cloudImg/master/images/image-20220604222117494.png)

代码

![image-20220604222221339](https://raw.githubusercontent.com/liang636600/cloudImg/master/images/image-20220604222221339.png)

![image-20220604222351747](https://raw.githubusercontent.com/liang636600/cloudImg/master/images/image-20220604222351747.png)

# 4 拟牛顿法

![image-20220605091016357](https://raw.githubusercontent.com/liang636600/cloudImg/master/images/image-20220605091016357.png)

![image-20220605094244733](https://raw.githubusercontent.com/liang636600/cloudImg/master/images/image-20220605094244733.png)

## DFP

使用Gk近似代表inv(H)

![image-20220605094533760](https://raw.githubusercontent.com/liang636600/cloudImg/master/images/image-20220605094533760.png)

![image-20220605094557458](https://raw.githubusercontent.com/liang636600/cloudImg/master/images/image-20220605094557458.png)

其中，这里g表示原函数f(x)的梯度

![image-20220605094653271](https://raw.githubusercontent.com/liang636600/cloudImg/master/images/image-20220605094653271.png)

![image-20220605094958684](https://raw.githubusercontent.com/liang636600/cloudImg/master/images/image-20220605094958684.png)

##  BFGS

使用Bk近似表示H

![image-20220605095446851](https://raw.githubusercontent.com/liang636600/cloudImg/master/images/image-20220605095446851.png)

![image-20220605095602308](https://raw.githubusercontent.com/liang636600/cloudImg/master/images/image-20220605095602308.png)

![image-20220605095808983](https://raw.githubusercontent.com/liang636600/cloudImg/master/images/image-20220605095808983.png)

![image-20220604225309905](https://raw.githubusercontent.com/liang636600/cloudImg/master/images/image-20220604225309905.png)

## L-BFGS

**时间换空间**

B矩阵可能较大，由于存储B矩阵可能占用较大空间，因此存储yk与δk的值（存储y1与δ1，y2与δ2，y3与δ3等），然后从B0迭代计算对应的Bk的值

但是,仅仅是这样还是不够的,因为当迭代次数非常大的时候,我们的内存同样存不下.这个时候只能丢掉一些存不下的数据.假设我们设置的存储向量数为100,当δ和y迭代超过100时,就会扔掉第一个δ和y,每多一次迭代就对应的扔掉最前边的s和y.这样虽然损失了精度,但确可以保证使用有限的内存将函数的解通过BFGS算法求得到.