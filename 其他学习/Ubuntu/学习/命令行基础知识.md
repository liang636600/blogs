# 1 命令行结构

命令形式 `命令名 命令选项 命令参数`，命令选项通常是以-开始的单个字符，也有--为起始标志的命令选项，其选项通常是可以按字面意义理解的单个英文单词

凡以[]形式给出的命令选项均为可选项

一次也可以输入多个命令，命令间以分号隔开，其效果同一次输入一个命令基本没有区别，而且都是在当前shell下运行。也可以使用()把若干命令组合在一起，构成一个组合命令，在一个子shell中运行，所有命令的输出数据将合并为一个输出流。两者差别在管道操作中明显，wc -l表示统计读入的行数，没有括号的时候，wc只统计了who的输入结果1行

![image-20211220200841001](https://raw.githubusercontent.com/liang636600/cloudImg/master/images/image-20211220200841001.png)

如果命令较长，超出一个物理行的宽度，可以使用反斜线\把命令写到多个物理行上

# 2 后台进程

为了以后台进程方式运行命令，只需在命令的后面增加一个&符号即可

![image-20211220201832972](https://raw.githubusercontent.com/liang636600/cloudImg/master/images/image-20211220201832972.png)

[1]表示find进程作业号，20539表示find进程的pid

可以使用作业控制命令fg把后台作业转为前台进程继续运行

如果后台进程有输出数据，其输出信息将会随时出现在用户的终端屏幕上

# 3 标准输入输出与错误输出

读取来自终端键盘的输入数据，称为标准输入（stdin），其文件描述符为0。结果输出到用户屏幕上，称为标准输出（stdout），其文件描述符为1。在命令的执行期间，如果出现问题，相应的错误信息也将输出到终端屏幕上，称作标准错误输出（stderr），其文件描述符为2.

# 4 I/O重定向

输出重定向符>，例如`ls -l > filename`，把ls的输出结果重定向到文件filename中去，如果文件不存在，shell将创建一个新文件。如果文件存在，则文件原来内容会被覆盖掉。

`>>`表示输出结果重定向并附加到文件后面，例如`ls -l >> filename`

任何标准输入也可以重定向，使命令直接读取某个文件。重定向符<，例如`wc -l < fname`

在linux系统中，系统将会为每一个打开的文件分配一个文件描述符，每个文件都与一个文件描述符相关联。文件描述符是一个数字，便于linux系统跟踪打开的文件。标准输入、标准输出和标准错误输出的文件描述符分别为0,1,2.

```
command > file	将输出重定向到 file。
command < file	将输入重定向到 file。
command >> file	将输出以追加的方式重定向到 file。
n > file	将文件描述符为 n 的文件重定向到 file。
n >> file	将文件描述符为 n 的文件以追加的方式重定向到 file。
n >& m	将输出文件 m 和 n 合并。把文件描述符n表示的输出文件重定向到文件描述符m表示的文件
n <& m	将输入文件 m 和 n 合并。
<< tag	将开始标记 tag 和结束标记 tag 之间的内容作为输入。
0<fname
1>fname
1>>fname
2>fname
2>>fname
```

如果希望 stderr 重定向到 file，`command 2>file`

如果希望 stderr 追加到 file 文件末尾,`command 2>>file`

如果希望将 stdout 和 stderr 合并后重定向到 file

```
$ command > file 2>&1

或者

$ command >> file 2>&1    
(2>&1表示把标准错误输出合并到标准输出中)
```

如果希望对 stdin 和 stdout 都重定向,`command < file1 >file2`，command 命令将 stdin 重定向到 file1，将 stdout 重定向到 file2

Here Document 是 Shell 中的一种特殊的重定向方式，用来将输入重定向到一个交互式 Shell 脚本或程序，它的基本的形式如下：

```
command << delimiter
    document
delimiter
```

它的作用是将两个 delimiter 之间的内容(document) 作为输入传递给 command

注意：

* 结尾的delimiter 一定要顶格写，前面不能有任何字符，后面也不能有任何字符，包括空格和 tab 缩进。
* 开始的delimiter前后的空格会被忽略掉。

```
$ wc -l << EOF
    欢迎来到
    菜鸟教程
    www.runoob.com
EOF
3          # 输出结果为 3 行
```

如果希望执行某个命令，但又不希望在屏幕上显示输出结果，那么可以将输出重定向到 /dev/null，`command > /dev/null`

/dev/null 是一个特殊的文件，写入到它的内容都会被丢弃；如果尝试从该文件读取内容，那么什么也读不到。但是 /dev/null 文件非常有用，将命令的输出重定向到它，会起到"禁止输出"的效果。

如果希望屏蔽 stdout 和 stderr，可以这样写：

```
$ command > /dev/null 2>&1
```

I/O重定向的顺序影响

```
command 1>fname 2>&1 表示 标准输出重定向到fname，然后标准错误输出重定向到标准输出指向的位置（即标准输出和标准错误输出均重定向到fname）
command 2>&1 1>fname 表示 标准错误输出 重定向到标准输出指向的位置（没用，他们本来就指向同一个位置），标准输出重定向到fname（表示标准输出重定向到fname，但标准错误输出仍输出到终端）
```

# 5 管道

利用管道符号|，可以把一个命令的标准输出连接到另一个命令的标准输入，例如`ls /usr | wc -w`

shell将会协调两个进程的同步，使两个进程能够并发地运行，这样就可以省略处理中间结果的临时文件，例如`ps -ef | grep cron`(cron表示关键字)

`command1 | command2 | command3 > filename`

实例

```
$ ps -ef | grep cron | grep -v grep
root         680       1  0 05:58 ?        00:00:00 /usr/sbin/cron -f
$ ps -ef | grep cron | grep -v grep | gawk '{print $2}'
680
```

# 6 元字符（通配符）

bash Shell本身不支持正则表达式，使用正则表达式的是Shell命令和工具，如grep、sed、awk等。但是，bash Shell可以使用正则表达式中的一些元字符实现`通配（Globbing）`功能

| 符号            | 意义                                                         |
| :-------------- | :----------------------------------------------------------- |
| ?               | 表示任意一个字符（a?，不包括a）                              |
| *               | 任意位的任意字符                                             |
| []              | 与正则表达式含义一致，匹配字符集合，可以使用其中任何一个字符匹配文件名相应位置的一个字符 |
| {}              | 表示一组表达式的集合                                         |
| [!...]或[ ^ ..] | 取反，如果方括号中的第一个字符是!或^，则其意义恰好相反，表示可以匹配任何一个不属于给定字符集范围的字符 |

`ls [a-z]*`表示任何以小写字母为起始字符的文件名

任何元字符都不能匹配以句号.为首字符的隐藏文件名。以句号为起始字符的隐藏文件名必须采用明显的匹配形式。`echo .*`

# 7 转义和引用

为了处理具有特殊意义的元字符，如<,>,*,?,|,&，使之作为普通字符显示，可以采用转义符号\，单引号（单引号中所有元字符均作为文字常量处理，raw字符串），双引号引用元字符（除了!,$,',\,{外，其他元字符均按文字本身处理），而引用的元字符则失去其特殊的意义。

# 8 作业控制

当运行一个较长时间才能完成的程序时，为了能够在此期间继续执行其他任务，可以使用Ctrl+z组合键及bg命令，把程序放入后台运行。按下Ctrl+z组合键时将会向shell和当前程序发送一个stop信号。

为了让stop的作业放在后台运行，使用`bg %1` （%1表示作业号，用jobs命令），

为了让一个正在后台运行的作业回到前台运行使用 `fg %2`

为了停止一个后台作业，使用`kill %1`

如果想在退出terminal后仍然确保后台运行的作业能够继续运行，直至其正常结束，可以利用nohup命令，例如`nohup a.sh &`