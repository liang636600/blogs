# ln

用来为文件或目录创建软连接和硬链接，
命令格式为：ln option dist   source
dist 为绝对路径

# ldconfig

ldconfig是一个动态链接库管理命令，为了让动态链接库为系统所共享,还需运行动态链接库的管理命令,主要是在默认搜寻目录(/lib和/usr/lib)以及动态库配置文件/etc/ld.so.conf内所列的目录下,搜索出可共享的动态链接库(格式如前介绍,lib*.so*),进而创建出动态装入程序(ld.so)所需的连接和缓存文件.缓存文件默认为 /etc/ld.so.cache,此文件保存已排好序的动态链接库名字列表
-p或--print-cache : 此选项指示ldconfig打印出当前缓存文件所保存的所有共享库的名字

# grep

用于查找文件里符合条件的字符串

`grep [选项] string [文件]`

string是一个检索模式。检索模式可以是一个准备检索的字符串，一个单词或短语。检索模式可以包含空格，标点符号甚至控制字符，但需要在前后增加引号。

选项：

-c 只输出匹配行的数量

-i 搜索时忽略大小写

-h 查询多文件时不显示文件名

-l 只列出符合匹配的文件名，而不列出具体的匹配行

-n 列出所有的匹配行，并显示行号

-s 不显示不存在或无匹配文本的错误信息

-v 显示不包含匹配文本的所有行

-w 匹配整词

-x 匹配整行

-r 递归搜索，不仅搜索当前工作目录，而且搜索子目录

-q 禁止输出任何结果，以退出状态表示搜索是否成功

-b 打印匹配行距文件头部的偏移量，以字节为单位

-o 与-b选项结合使用，打印匹配的词距文件头部的偏移量，以字节为单位

-E 支持扩展的正则表达式

-F 不支持正则表达式，按照字符串的字面意思进行匹配

## 实例说明

搜索 00.txt文件中包含 hello 字符串的行

```
grep hello 00.txt
```

搜索 00.txt文件中包含 hello world 字符串的行

```
# 需要用引号将待搜索的字符串引起来
grep "hello world" 00.txt
```

使用通配符指定 grep所搜索的文件

```
grep "hello world" 0?.txt

[output]
00.txt:hello world
03.txt:hello world
```

显示不包含匹配字符串的行数量

```
grep -vc hello *.txt
```

## grep,egrep,fgrep

* grep -E 和 grep -F 分别等价于 egrep 和 fgrep
* grep 支持正则表达式
* egrep 扩展 grep 命令，支持正则表达式和扩展正则表达式
* fgrep 快速 grep 命令，不支持正则表达式

## 过滤其他命令的输出数据

过滤其他命令的输出结果，从命令输出中抽取含有某种特征的数据，例如`ls -l | grep 19`

## 同时检索多个文件

当找出匹配检索模式的字符串时，grep会在输出信息前冠以文件的名字，然后输出匹配检索模式的文本行。例如`grep capital *`(就当前目录，不递归到子目录)

## 使用正则表达式进行检索

特殊字符对linux系统也有特殊含义。因此，在grep命令中使用正则表达式时，需要通过转义机制，使系统在解释命令行期间忽略这些元字符的特殊含义

| 元字符 | 简单说明                                                 |
| ------ | -------------------------------------------------------- |
| ^      | 匹配文本行的行首                                         |
| $      | 匹配文本行的行尾                                         |
| .      | 匹配任何一个单字符(必须要匹配，即使是空格符，但不能没有) |
| [...]  | 匹配字符集或字符范围中的任何一个字符                     |
| [^...] | 匹配不属于字符集或字符范围中的任何一个字符               |
| *      | 匹配0个或多个同一字符或正则表达式                        |
| +      | 匹配一个或多个同一字符或正则表达式                       |
| \      | 随后的元字符作为普通字符处理                             |

如果检索模式中包含元字符，且需要忽略其特殊含义时，可在元字符之前增加转义符号

`grep '^T' a.txt`，找出输入文件中以字符T为行首字符的所有文本行

`ls -l | grep '^d'`，为了仅仅列出当前目录中的子目录

`ls -lR | grep '^d'`，递归列出当前目录中的所有子目录

`grep -n '^$' a.txt`，找出空行并显示行号

`grep 'ro*' a.txt`，找出含有一个字符r和0个或多个字符o（例如r，ro，roo）的所有文本行

`grep '.*' a.txt`，匹配0个或多个任意字符的所有文本行

## 检索元字符本身

可以在元字符前面加转义符号\

`grep '^\.' somefile`，返回以句点为起始的文本行

# awk

awk是一种处理文本文件的语言，是一个强大的文本分析工具

语法

```
awk [选项参数] 'script' var=value file(s)
或
awk [选项参数] -f scriptfile var=value file(s)
```

## 基本用法

log.txt文本内容如下：

```
2 this is a test
3 Are you like awk
This's a test
10 There are orange,apple,mongo
```

```
awk '{[pattern] action}' {filenames}   # 行匹配语句 awk '' 只能用单引号
```

实例：

```
# 每行按空格或TAB分割，输出文本中的1、4项，$1就是第一个
 $ awk '{print $1,$4}' log.txt
 ---------------------------------------------
 2 a
 3 like
 This's
 10 orange,apple,mongo
 # 格式化输出
 $ awk '{printf "%-8s %-10s\n",$1,$4}' log.txt
 ---------------------------------------------
 2        a
 3        like
 This's
 10       orange,apple,mongo
```

# find

用来在指定目录下查找文件（目录及子目录）。任何位于参数之前的字符串都将被视为欲查找的目录名。如果使用该命令时，不设置任何参数，则 find 命令将在当前目录下查找子目录与文件。并且将查找到的子目录和文件全部进行显示。

```
find   directory   -option   [   -print ]   [ -exec   -ok   command ]   {} \;
```

其中，directory是检索的起始目录，options用于指定各种匹配准则或检索条件

find命令的部分常用选项

-name filename检索匹配指定文件名的所有文件。如果指定的文件名中包含通配符*？和[...]，文件名前后应加单引号或双引号

-user username检索其文件属主匹配指定用户的所有文件

-group groupname

-atime n 选择在n天之前，之内或恰好n天访问过的文件

-ctime n 选择在n天之前，之内或恰好n天状态信息发生变动的文件（创建日期）

-mtime 选择在n天之前，之内或恰好n天修改过文件内容的文件（-mtime -10最近10天内修改过）

-newer finename 修改日期比给定文件更近的文件

-size [+-]n[KMG] 按照指定的文件大小数值n检索符合条件的文件，KMG表示KB,MB,GB，其中+n表示大于指定的数量，n表示恰好等于指定的数量，-n表示小于指定的数量

-type filetype 检索指定类型的文件。其中文件的类型可以是

* f：普通文件
* d：表示目录
* l：表示符号链接文件

-exec cmd {} \ [; | +] 把find命令的检索结果作为参数提交给指定命令，由给定的命令作进一步的加工处理。后面的花括号表示给定命令的参数将由find命令的输出结果予以替换。命令的后面必须以转义的分号\;或转义的加号\ +结束

* 例如想要删除当前目录及子目录中扩展名为.tmp的所有文件`find . -name '*.tmp' -exec rm {} \+`

当命令以加号结束时，意味者把find命令的输出结果汇总为一个参数集合，然后一次性地提交给定的命令。因此使用+能够改善命令的运行性能

find命令允许用户使用逻辑非!，逻辑与-a，逻辑或-o等逻辑运算符组合各种选项，定义更为严格的检索准则。在使用逻辑表达式时，组合选项前后要加一对转义的圆括号。

`find /etc ! -user root`

`find / -type d -a -user gqxing`

`find / \( -name '*.o' -o -name a.out \) -atime +30`

`find pathname -type f | xargs chmod 644`

### 实例

将当前目录及其子目录下所有文件后缀为 **.c** 的文件列出来:

```
# find . -name "*.c"
```

将当前目录及其子目录中的所有文件列出：

```
# find . -type f
```

将当前目录及其子目录下所有最近 20 天内更新过的文件列出:

```
# find . -ctime -20
```

查找 /var/log 目录中更改时间在 7 日以前的普通文件，并在删除之前询问它们：

```
# find /var/log -type f -mtime +7 -ok rm {} \;
```

查找当前目录中文件属主具有读、写权限，并且文件所属组的用户和其他用户具有读权限的文件：

```
# find . -type f -perm 644 -exec ls -l {} \;
```

查找系统中所有文件长度为 0 的普通文件，并列出它们的完整路径：

```
# find / -type f -size 0 -exec ls -l {} \;
```



# wget

例如`wget http://cn.wordpress.org/wordpress-3.1-zh_CN.zip`
指定下载的文件名，例如`wget -O wordpress.zip http://www.centos.bz/download.php?id=1080`
断点续传，例如 `wget -c http://cn.wordpress.org/wordpress-3.1-zh_CN.zip`
对于我们下载大文件时突然由于网络等原因中断非常有帮助，我们可以继续接着下载而不是重新下载一个文件。需要继续中断的下载时可以使用-c参数。

# man

man <command> 进入命令帮助文档，类似ls --help

# date

列出当前日期和时间

# uname

用于显示系统信息，可显示电脑及操作系统的相关信息

-s 显示操作系统名称

-n 列出系统名字，显示在网络上的主机名称

-a 显示全部信息

-m 显示电脑类型x86_64

-v 显示操作系统的版本

# wc

计算输入的byte数，字数，行数

-c 只显示byte数

-l 显示行数

-w 只显示字数

在默认的情况下，wc将计算指定文件的行数、字数，以及字节数。使用的命令为：`wc testfile `，

```
$ wc testfile           # testfile文件的统计信息  
3 92 598 testfile       # testfile文件的行数为3、单词数92、字节数598 
```

```
$ wc testfile testfile_1 testfile_2  #统计三个文件的信息  
3 92 598 testfile                    #第一个文件行数为3、单词数92、字节数598  
9 18 78 testfile_1                   #第二个文件的行数为9、单词数18、字节数78  
3 6 32 testfile_2                    #第三个文件的行数为3、单词数6、字节数32  
15 116 708 总用量                    #三个文件总共的行数为15、单词数116、字节数708 
```

# cat

用于连接文件并打印到标准输出设备上

cat命令也可以查看文件内容`cat file`

cat命令也可以用于创建新文件

```
$ cat > b
hello 
what a good life
Ctrl+D（不显示，文件结束符）
```

-n 由1开始对所有输出的行数编号

-b 和-n相似，对于空白行不编号

-s 当遇到有连续两行以上的空白行，代换为一行的空白行

-E 在每行结束处显示$

把 textfile1 的文档内容加上行号后输入 textfile2 这个文档里：

```
cat -n textfile1 > textfile2
```

把 textfile1 和 textfile2 的文档内容加上行号（空白行不加）之后将内容附加到 textfile3 文档里：

```
cat -b textfile1 textfile2 >> textfile3
```

清空 /etc/test.txt 文档内容：

```
cat /dev/null > /etc/test.txt
```

# tee

tee命令的主要功能是通过标准输入接受并显示数据，同时把数据存储到指定的文件中

例如`who | tee userlist`

# pwd

显示工作目录，目前所在的工作目录的绝对路径名称

# jobs

查询后台作业信息，使用jobs命令列出系统中的所有作业，包括作业号，作业运行状态，作业的命令行

![image-20211221171032439](https://raw.githubusercontent.com/liang636600/cloudImg/master/images/image-20211221171032439.png)

# which

可以找出当前究竟执行的是哪一个目录下的同名命令，which命令并不考虑内置命令，它仅检索并给出发现的第一个外部命令

```
$ which tar
/usr/bin/tar
```

# whereis

用于检索与给定命令相关的文件（根据标准的目录位置，而非检索路径）

```
$ whereis tar
tar: /usr/bin/tar /usr/share/man/man1/tar.1.gz
```

# file

用于辨识文件类型

例如`file a.txt`

# od

用于输出文件内容，读取所给予文件的内容，并将内容以八进制字码呈现出来

# touch

以当前（或指定）的时间更新给定文件的访问和修改时间。如果指定的文件不存在，则创建一个新的空文件

# ls

`ls [选项] dir-or-file`

-a 列出指定目录下的所有文件，包括以.为起始字符的隐藏文件

-d 如果指定的参数是一个目录，仅列出目录的名字，与-l一起使用以了解目录的属性信息

-h 以KB，MB，GB形式显示文件大小，与-l一起使用

-i 对于每一个文件，在第一列列出其信息节点号

-l 以每行一个文件的长格式列出文件的类型，访问权限，链接数，用户属主，用户组，文件大小，最后修改时间和文件名等信息。

-R 递归地列出指定目录及其子目录下的所有文件

-s 显示分配给文件的数据块（1024字节）的数量，也即文件占用的数据块数量，而非文件的实际大小

-k 以KB为单位给出文件的大小

# more

逐页逐屏地显示整个文件的内容

`more [option] file`

# less

less命令分页显示文件内容

# head

显示文件前几行的内容(默认前10行的内容)

例如`head /etc/profile`

# tail

显示文件最后几行内容（默认后10行）

对于不断增长的日志文件，有时候需要持续地监控文件不断出现的最新信息。可以使用`tail -f file`

# cp

复制文件

-r 如果复制的是目录的话，会递归地复制目录中的所有文件

# mv

移动文件或重命名文件

`mv source_file target_file`

# basename

剔除文件名中的目录部分，使之仅包含文件名本身，或剔除文件名的扩展名后缀

`basename string [suffix]`

# rm

-f 表示强制删除文件

# mkdir

创建多级目录`mkdir -p /hello/world`

# diff

比较文件之间的差别

`diff file1 file2`

如果两者之间的差别是由于插入新的文本行造成的，diff命令将会采用下列形式显示新增加的行`lline#1[,#line#2] a rline#1[,rline#2]`

如果两者之间的差异是由于删除文本行造成的，diff程序将采用下列形式显示哪一个文件删除了文本行`lline#1[,lline#2] d rline#1[,rline#2]`

如果两者之间的差异是由于修改文本行造成的，`lline#1[,lline#2] c rline#1[,rline#2]`

在上述的任何情况下，两个文件中的相关文本行将会随行号一并给出。第一个文件中的文本行前面冠以<，第二个文件中的文本行前面冠以>

# sort

对输入数据或文件内容进行排序，使其按照一定的顺序逐行显示

`sort [-bdfimnru] -k start [,stop] -t char -o outfile [file]`

其中file表示待排序的文件

-b 忽略文本行前置的空白字符

-d 仅考虑字符数字空格字符，忽略标点符号等字符，按字典顺序排列

-f 排序时忽略字母的大小写，所有的小写字母均做大写字母处理，统一进行排序

-k 表示排序字段的字段位置，或排序字段的起止字符位置及范围。如果没有明确指定排序字段，默认的排序字段为整个文本行。从1开始编号。还可以指定多个字段，例如`sort -k 1 -k 2 namelist`

-o outfile 指定存储排序结果的输出文件

-r 按从大到小或反向字符的顺序排序

-t char 用于指定除空白字符之外的其他字段分隔符

-n 按照字符串的数值而不是文字进行排序

经常用于排序其他命令的输出结果，例如`ls -l | sort -k 5 -rn`

# ps

`ps [-aAcefFHlW] [-g grouplist] [-p pidlist] [-t termlist] [-u userlist]`

-a 显示系统中所有活动进程的当前状态信息（与终端无关联的进程除外）

-A 活儿-e 显示系统中当前所有进程的状态信息

-c 与-l选项一起使用时能够显示进程的调度信息，包括进程的调度类别与优先级等

-f 显示进程的重要状态信息，尤其是进程的起始运行时间和进程占用的cpu时间等

-F 与-f选项相比，能够显示更多重要的进程状态信息

-H 以表示进程调用层次关系的缩进形式显示所有进程的状态信息

-l 显示进程的详细状态信息（起始运行时间除外）

-g grouplist 显示与指定的有效用户组ID或用户组名有关的进程状态信息

-p pidlist 显示指定进程ID的进程状态信息

-t termlist 显示与指定的终端设备相关的进程状态信息

-u userlist 显示与指定的有效用户ID或用户名相关的进程状态信息

# pgrep与pidof

直接获取指定进程的PID，例如`pidof apache2`，`pgrep bash`

# kill

无条件杀死一个进程，`kill -9 pid`

# df

查询每个文件系统磁盘空间的使用与空闲情况

`df [-ahiklTv] [-B size] [-t fstype] [-x fstype] [filesys]` 

-a 显示所有文件系统（包括虚拟文件系统如/proc）的存储空间及其使用情况

-B size 以指定的字节数量为单位，显示每个已安装文件系统的磁盘空间使用情况。输出信息包括文件系统的设备文件名，文件系统总容量，已分配的存储空间容量，可用的存储空间容量，已用存储空间占文件系统总容量的百分比，以及文件系统的安装点。

-h 以KB,MB,GB为单位，显示每个已安装文件系统的使用情况

-l 显示已安装的本地文件系统的存储空间使用情况，包括可用的存储空间容量，以及可用的文件信息节点数量等

# du

显示指定目录（或当前目录）中每个子目录或文件占用的磁盘空间数量

`du [-abchkms] [-B size] [directory]`

-a 列出指定目录或当前目录中每个文件，每个子目录，以及其中每个文件占用的磁盘空间数量，最终给出整个目录占用的磁盘空间数量。如果指定的参数是一个普通文件，则显示指定文件占用的存储空间

-B size 以指定的字节数为计数单位，显示指定目录以及其中所有子目录占用的磁盘空间数量

-h 以KB,MB,GB为单位

-s 如果只想查询某个目录占用的全部存储空间数量

统计一个目录下各文件夹的大小（不递归）并排序`ls -l | grep '^d' | awk '{print $9}' | xargs du -sk | sort -k 1 -rn`

# fdisk

可用于划分磁盘设备，显示磁盘分区信息。语法如下

```
fdisk [-u] [-b sectorsize] [-C cyls] [-H heads] [-S sects] device
fdisk -l [-u] [device]
fdisk -s partition
```

-l 选项用于显示指定磁盘设备的分区表。如果未给定磁盘设备，则输出/etc/fstab文件中列举的，以及系统检测到的每个存储设备的分区表。

-u 表示以扇区（而不是以柱面）为单位列出每个设备分区的起始数据块位置

-s 表示以数据块为单位显示指定设备分区的容量

如果磁盘已经分区，并分别创建了不同的文件系统，为了获取磁盘的分区信息，可以使用`fdisk -l /dev/sda`

# mount

mount用于安装文件系统或远程共享资源，umount用于卸载文件系统和远程共享资源

mount主要功能是把指定设备中的文件系统安装到指定的目录中

`mount -t fstype device directory`

device表示文件系统的设备文件名，如/dev/sda4，directory表示安装点

确定系统当前已经安装了哪些文件系统`mount`或`cat /etc/mtab`

# time

量测特定指令执行时所需消耗的时间及系统资源，语法

`time [option] command [arguments]`

-o 设定结果输出文件

* real时间是指挂钟时间，也就是命令开始执行到结束的时间。这个短时间包括其他进程所占用的时间片，和进程被阻塞时所花费的时间。
* user时间是指进程花费在用户模式中的CPU时间，这是唯一真正用于执行进程所花费的时间，其他进程和花费阻塞状态中的时间没有计算在内。
* sys时间是指花费在内核模式中的CPU时间，代表在内核中执系统调用所花费的时间，这也是真正由进程使用的CPU时间。

真正花费的时间是user+sys
