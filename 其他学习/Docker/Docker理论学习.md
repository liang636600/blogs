# Docker

用户可以将镜像内容和创建步骤描述在一个文本文件中，这个文件被称为Dockerfile，通过执行`docker build <docker-file>`命令可以构建出docker镜像
仓库注册服务器（registry）是存放仓库的地方，仓库是存放镜像的地方（每个仓库集中存放一类镜像），通过不同标签区分
docker镜像采用了写时复制（copy on write）的策略，在多个容器之间共享镜像，每个容器在启动的时候并不需要单独复制一份镜像文件，而是将所有镜像层以只读的方式挂载到一个挂载点，再在上面覆盖一个可读写的容器层。如果Docker容器需要改动底层Docker镜像中的文件，则会启动copy on write机制，即先将此文件从镜像层中复制到最上层的可写层中，再对可写层中的副本进行操作。
docker镜像采用统一文件系统（union file system）对各层进行管理。统一文件系统技术能将不同的层整合成一个文件系统，为这些层提供一个统一的视角，这样隐藏了多层的存在，从用户的角度看，只存在一个文件系统
一个镜像仓库中可以包含同一个软件的不同镜像，利用标签进行区别。可以利用`仓库名:标签名`的格式来指定相关软件镜像的版本。例如，`hbliti/nginx:version1.0.test`表示仓库名为hbliti，镜像名为nginx，标签名为version1.0.test。如果要将镜像推送到一个私有的registry，则必须指定一个主机名和端口号来标记此镜像，如192.168.1.103:5000/nginx:version1.1.test

# Dockerfile
## RUN指令
是用于在镜像中执行命令的指令，它接受命令作为参数并用于创建镜像。RUN指令有以下两种格式
```
RUN <command>
RUN ["executable","param1","param2"]
```
Dockerfile的每一个指令都会构建新文件层。在AUFS中，所有的镜像最多只能保存126层，而执行一次RUN就会产生一个新文件，并在其上执行命令，执行完毕后提交这一层的修改构成新的镜像。对于一些需要合并为一层的操作，可以使用&&符号将多个命令分割开，使其先后执行
## CMD指令
与RUN指令基本相似
```
格式1 CMD ["executable","param1","param2"]
格式2 CMD ["param1","param2"]
格式3 CMD command param1 param2
```
当用户需要脱离shell环境来执行命令时，可以使用格式1的用法，其设定的命令将作为容器启动时的默认执行命令
当使用指令格式2时，其中的param作为ENTRYPOINT的默认参数使用
当使用指令格式3时，以"/bin/sh -c"的方法执行命令
`CMD "/usr/sbin/nginx -c /etc/nginx/nginx.conf"`，在一个Dockerfile中只有最后一条CMD指令生效。同时CMD中只能使用双引号不能使用单引号
CMD指令与RUN指令的区别是，RUN指令在docker build时执行，而CMD指令在docker run时运行，CMD的首要目的在于为指定的容器指定默认要运行的程序，程序运行结束，容器也就结束了。CMD指令指定的程序可被docker run命令行参数中指定的要运行的程序覆盖

## ENTRYPOINT指令
类似CMD指令，但其不会被docker run的命令行参数指定的指令所覆盖，且这些命令行参数会被当作参数送给ENTRYPOINT指令指定的程序。但是，如果运行docker run时使用了--entrypoint选项，则此选项的参数可当作要运行的程序覆盖ENTRYPOINT指令指定的程序
```
ENTRYPOINT command
ENTRYPOINT ["executable","param1","param2"]
```
当指定了ENTRYPOINT指令时，CMD指令中的命令性质将会发生改变，CMD指令中的内容将会以参数形式传递给ENTRYPOINT指令中的命令。把可能需要变动的参数写到CMD中并在docker run命令中指定参数，这样CMD指令中的参数就会被覆盖，而ENTRYPOINT指令中的参数不会被覆盖
## ENV指令
设置环境变量
```
ENV key value
ENV key1=value1 key2=value2
```
## ARG指令
定义构建时需要的参数
`ARG <参数名>[=<默认值>]`
使用ARG指令定义参数，在利用docker build命令创建镜像的时候可使用格式--build-arg <varname>=<value>来指定参数

## ADD指令
将主机目录中的文件，目录及一个URL标记的文件复制到镜像中
```
ADD src dest
```
dest指定的路径必须是绝对路径或相对于WORKDIR的相对路径。如果dest指定的路径不存在，则当ADD指令执行时，将会在容器中自动创建此目录
## COPY指令
COPY指令与ADD指令的功能及使用方法基本相同，只是COPY指令不会做自动解压工作
## VOLUME指令
可实现挂载功能，可以将本地文件夹或其他容器的文件夹挂载到某个容器中
```
VOLUME 路径
VOLUME ["路径1","路径2"]
```
VOLUME指令可以将容器及容器产生的数据分离开来，这样，当利用docker rm container命令删除容器时，不会影响相关数据
## EXPOSE指令
声明运行时的容器服务端口
`EXPOSE 端口`
EXPOSE指令只是声明了容器应该打开的端口，实际上并没有打开该端口，在容器启动时，如果不用-p指定要映射的端口，则容器是不会将端口映射出去的，外部网络也无法访问这些端口，这些端口只能被主机中的其他容器访问

## WORKDIR指令
用于设置容器的工作目录
`WORKDIR 工作目录`，Dockerfile文件中允许出现多个WORKDIR，但最终生效的路径是所有WORKDIR指定路径的叠加，WORKDIR可以通过docker run命令中的-w参数进行覆盖

# CGroups
CGroups是Linux内核提供的一种可以限制单个进程或多个进程所使用资源的机制
# 数据卷和数据容器
**数据卷:** 通过在容器中创建数据卷，将本地的目录或文件挂载到数据卷中。数据卷是一个可供容器使用的特殊目录，它将本地主机目录直接映射到容器，可以很方便地将数据添加到容器中供其中的进程使用，多个容器可以共享一个数据卷
**数据卷容器:** 通过使用数据卷容器在容器和主机，容器和容器之间共享数据，实现数据的备份和恢复。如果用户需要在多个容器之间共享一些持久化数据，则可以使用数据卷容器，数据卷容器专门用于提供数据卷供其他容器挂载

# Compose
定义和运行多个Docker容器应用的工具。Compose用过YMAL配置文件来创建和运行所有服务
**服务:** 一个应用的容器，实际上可以包含若干运行相同镜像的容器实例。每个服务都有自己的名称，使用的镜像，挂载的数据卷，所属的网络，依赖的服务等
**项目:** 由一组关联的应用容器组成的一个完整业务单元，在docker-compose.yml中定义，即Compose的一个配置文件可以解析为一个项目，Compose通过分析指定配置文件，得出配置文件所需完成的所有容器管理与部署操作
Compose的默认管理对象是项目，通过子命令对项目中的一组容器进行便携的生命周期管理
