正则表达式用于从字符串里面匹配符合特定规则的子串。

* 元字符转义`\`，对于像`.`这样的元字符需要通过`\`做转义，例如匹配ip地址 `\d+\.\d+\.\d+\.\d+`

* `r''`的含义表示不要对字符串进行python语法的转义，例如`r'\t'`可以避免`\t`被转义为tab（规避反斜杠的转义），python中单纯的单引号双引号没有区别
* 默认按行匹配（因为.不匹配换行符，不跨行）

| 符号   | 描述                                                         |
| ------ | ------------------------------------------------------------ |
| .      | 匹配除换行符\n外的任意字符                                   |
| *      | 匹配前一个字符0次或多次                                      |
| +      | 匹配前一次字符1次或多次                                      |
| ？     | 非贪婪方式匹配前一个字符0次或1次，通俗理解为可出现也可不出现 |
| ^      | 匹配文本起始位置，例如多行模式`^a`匹配每行开头的a，单行模式（默认单行）匹配整个文本开头 |
| $      | 匹配文本结束位置                                             |
| \s     | 匹配空白字符，如空格，制表符，换页符。等价于[\f\n\r\t\v]     |
| \S     | 匹配任何非空白字符                                           |
| \d     | 匹配数字，等价于[0-9]                                        |
| \D     | 匹配任何非数字，等价于`[^0-9]`                               |
| \w     | 匹配字母数字及下划线，等价于[A-Za-z0-9_]                     |
| \W     | 匹配非字母数字及下划线                                       |
| []     | 匹配[]中列举的任意字符，例如[amk]匹配'a'或'm'或'k',[0-9]匹配任何数字，注一些元字符在[]失去魔法，例如`.`在[]中表示实际的`.`而不表示任意字符 |
| [^...] | 不在[...]中的字符，例如`[^0-9a-z]`表示非数字字符，非字母a-z  |
| {n,}   | 重复n次或更多次                                              |
| {n,m}  | 重复n次到m次                                                 |
| a\|b   | 匹配a或b，例如`I love (cats|dogs)`                           |
| (re)   | 匹配括号内的表达式，也表示一个组，匹配一次或多次re 即(re)+   |
| \b     | 匹配一个单词边界，也就是指单词和空格间的位置，自身不匹配任何字符。例如`er\b`可以匹配never中的er，但不能匹配verb中的er。例如匹配一个单词`\bhello\b`匹配单词hello |
| \B     | 匹配非单词边界。`er\B`能匹配verb中的er，但不能匹配never中的er |

# 贪婪模式与非贪婪模式

贪婪模式和非贪婪模式指的是`*`和`+`，其中较常用的是`.*?`与`.*`，用来前后截取一段特征数据。`.*`是贪婪匹配，会尽可能往后匹配（默认贪婪模式），`.*?`是非贪婪匹配，会尽可能少匹配单词（在`*`或`+`后加上`?`表示`*或+`尽可能少的匹配）

python默认是贪婪匹配的。例如，正则表达式`ab*`,如果用于查找abbbc，贪婪匹配将找到abbb，非贪婪匹配将找到a

* 贪婪匹配

  ![image-20230414104031176](D:%5CBackUp%5C%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99%5C%E5%9B%BE%E7%89%87%5Cimage-20230414104031176.png)

* 非贪婪匹配

  ![image-20230414104115284](D:%5CBackUp%5C%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99%5C%E5%9B%BE%E7%89%87%5Cimage-20230414104115284.png)

# re.match

成功匹配返回Match对象

* Match属性
  * string：匹配时使用的文本
  * re：匹配时使用的pattern对象
  * pos：文本中正则表达式开始搜索的索引。其值与Pattern.match()和Pattern.search()方法的同名参数相同
  * endpos：文本中正则表达式结束搜索的索引，默认为string.length。其值与Pattern.match()和Pattern.search()方法的同名参数相同
  * lastindex：最后一个被捕获的分组在文中的索引，如果没有被捕获的分组，将为None
  * lastgroup：最后一个被捕获的分组的别名。如果这个分组没有别名或没有被捕获的分组，将为None
* Match方法
  * group：获得一个或多个分组截获的字符串；指定多个参数时将以元组形式返回。参数可以使用编号也可以使用别名。编号0代表整个匹配的子串，不填写参数时，返回group(0);没有截获字符串的组返回None;截获了多次的组返回最后一次截获的子串
  * groups：以元组的形式返回全部分组截获的字符串。相当于调用group(1,2,3...last)。
  * start([group])：返回指定的组截获的子串在string中的起始索引（子串第一个字符的索引）。group默认值为0
  * end([group])：返回指定的组截获的子串在string中的结束索引（子串的最后一个字符的索引+1）。group默认值为0
  * span([group])：返回(start(group),end(group))

![1642086328840](https://raw.githubusercontent.com/liang636600/cloudImg/master/images/1642086328840.jpg)

pattern里一共有四个组，0表示原串

![1642127600629](https://raw.githubusercontent.com/liang636600/cloudImg/master/images/1642127600629.jpg)

# 分组

从匹配的字符串中提取一部分内容用().例如，一个字符串"我的密码是:123abc你帮我记住".从中可见密码左边是英文冒号，右边是你。当构造一个正则表达式`:.*?你`，得到结果如下`:123abc你`。英文冒号和你并不是密码，如果只想要“123abc”，就使用小括号提取，即构造一个正则表达式`:(.*?)你`，得到的结果如下`123abc`

除了简单判断是否匹配之外，正则表达式还有**提取子串**(从匹配的字符串中再选)的强大功能。用()表示的就是要提取的分组(Group)。例如`^(\d{3})-(\d{3,8})$`分别定义了两个组，可以直接从匹配的字符串中提取出区号和本地号码

```python
import re
m = re.match(r'^(\d{3})-(\d{3,8})$','010-12345')
print(m.group(0))
print(m.group(1))
print(m.group(2))

# 结果
# 010-12345
# 010
# 12345
```

多个分组嵌套

```
Jan 1987
May 1969
May 1969
```

模式

```
([\w]{3} (\w{4}))
```

![image-20220114113529260](https://raw.githubusercontent.com/liang636600/cloudImg/master/images/image-20220114113529260.png)

# 切分字符串

例如`re.split(r'\s+',text)`将字符串按空白字符分割为列表

分隔符既有,又有;的情况

```
strs = re.split(r'[,;\s]+','a,b;; c d')
# ['a', 'b', 'c', 'd']
```

# re.findAll

返回的是一个列表，如果没有小括号，返回匹配到的字符串列表，如果有小括号，返回匹配到的字符串中小括号提取的值（如果有n个小括号，则返回匹配的多个tuple，每个tuple里有n个小括号对应的值），例如

```python
# 有小括号
import re
mystr = '你真好你很好你非常好'
strs = re.findall(r'你(.*?)好',mystr) #结果['真', '很', '非常']

# pattern中有多个小括号,返回list，list中每个值为一个匹配结果中的提取值元组
import re
mystr = '你真好你很好你非常好'
strs = re.findall(r'你(.*?)好你(.*?)好',mystr) # 结果[('真', '很')]

# 没有小括号
import re
mystr = '你真好你很好你非常好'
strs = re.findall(r'你.*?好',mystr) # 结果 ['你真好', '你很好', '你非常好']
```

# 替换

## 替换为固定值

````python
newStr = re.sub(r'/av\d+?/', '/cn345677/' , content)
print(newStr)
````

## 指定替换函数

```python
# 替换函数，参数是 Match对象
def subFunc(match):
    # Match对象 的 group(0) 返回的是整个匹配上的字符串， 
    src = match.group(0)
    
    # Match对象 的 group(1) 返回的是第一个group分组的内容
    number = int(match.group(1)) + 6
    dest = f'/av{number}/'

    print(f'{src} 替换为 {dest}')

    # 返回值就是最终替换的字符串
    return dest

newStr = re.sub(r'/av(\d+?)/', subFunc , names)
print(newStr)
```

# 指定正则表达式标记

* \w只为ASCII码

  ```python
  p=re.compile(r'\w{2,4}', re.A) # 表示\w只表示ASCII码，否则\w可表示中文单个汉字
  print(p.findall(context))
  ```

* 多行模式 `^`与`$`表示每行的开始和结束（默认为单行模式，`^`与`$`表示文本开始和结尾）

  ````python
  p=re.compile(r'^\d+', re.M) 
  ````

* 大小写不敏感（默认情况下严格区分大小写）

  ```python
  p=re.compile(r'\w+', re.I) 
  ```

  