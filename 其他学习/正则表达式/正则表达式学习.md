正则表达式是对字符串操作的一种逻辑公式，用于从字符串里面提取符合特定规则的子串。

| 符号   | 描述                                                         |
| ------ | ------------------------------------------------------------ |
| .      | 匹配除换行符\n外的任意字符                                   |
| *      | 匹配前一个字符0次或多次                                      |
| +      | 匹配前一次字符1次或多次                                      |
| ？     | 非贪婪方式匹配前一个字符0次或1次                             |
| ^      | 匹配字符串开头                                               |
| $      | 匹配字符串结尾                                               |
| \s     | 匹配空白字符，如空格，制表符，换页符。等价于[\f\n\r\t\v]     |
| \S     | 匹配任何非空白字符                                           |
| \d     | 匹配数字，等价于[0-9]                                        |
| \D     | 匹配任何非数字，等价于`[^0-9]`                               |
| \w     | 匹配字母数字及下划线，等价于[A-Za-z0-9_]                     |
| \W     | 匹配非字母数字及下划线                                       |
| []     | 匹配[]中列举的字符，例如[amk]匹配'a'或'm'或'k',[0-9]匹配任何数字 |
| [^...] | 不在[...]中的字符                                            |
| {n,}   | 重复n次或更多次                                              |
| {n,m}  | 重复n次到m次                                                 |
| a\|b   | 匹配a或b，例如`I love (cats|dogs)`                           |
| (re)   | 匹配括号内的表达式，也表示一个组                             |
| \b     | 匹配一个单词边界，也就是指单词和空格间的位置，自身不匹配任何字符。例如`er\b`可以匹配never中的er，但不能匹配verb中的er。例如匹配一个单词`\bhello\b`匹配单词hello |
| \B     | 匹配非单词边界。`er\B`能匹配verb中的er，但不能匹配never中的er |

其中较常用的是`.*?`与`.*`，用来前后截取一段特征数据。`.*`是贪婪匹配，会尽可能往后匹配，`.*?`是非贪婪匹配，会尽可能少匹配单词

python默认是贪婪匹配的。例如，正则表达式`ab*`,如果用于查找abbbc，贪婪匹配将找到abbb，非贪婪匹配将找到a

从一段字符串中提取一部分内容用().例如，一个字符串"我的密码是:123abc你帮我记住".从中可见密码左边是英文冒号，右边是你。当构造一个正则表达式`:.*?你`，得到结果如下`:123abc你`。英文冒号和你并不是密码，如果只想要“123abc”，就使用小括号提取，即构造一个正则表达式`:(.*?)你`，得到的结果如下`123abc`

默认情况下严格区分大小写

# re.match

成功匹配返回Match对象

* Match属性
  * string：匹配时使用的文本
  * re：匹配时使用的pattern对象
  * pos：文本中正则表达式开始搜索的索引。其值与Pattern.match()和Pattern.search()方法的同名参数相同
  * endpos：文本中正则表达式结束搜索的索引`)`，默认为string.length。其值与Pattern.match()和Pattern.search()方法的同名参数相同
  * lastindex：最后一个被捕获的分组在文中的索引，如果没有被捕获的分组，将为None（？）
  * lastgroup：最后一个被捕获的分组的别名。如果这个分组没有别名或没有被捕获的分组，将为None
* Match方法
  * group：获得一个或多个分组截获的字符串；指定多个参数时将以元组形式返回。参数可以使用编号也可以使用别名。编号0代表整个匹配的子串，不填写参数时，返回group(0);没有截获字符串的组返回None;截获了多次的组返回最后一次截获的子串
  * groups：以元组的形式返回全部分组截获的字符串。相当于调用group(1,2,3...last)。
  * start([group])：返回指定的组截获的子串在string中的起始索引（子串第一个字符的索引）。group默认值为0
  * end([group])：返回指定的组截获的子串在string中的结束索引（子串的最后一个字符的索引+1）。group默认值为0
  * span([group])：返回(start(group),end(group))

![1642086328840](https://raw.githubusercontent.com/liang636600/cloudImg/master/images/1642086328840.jpg)

pattern里一共有四个组，0表示原串

![1642127600629](https://raw.githubusercontent.com/liang636600/cloudImg/master/images/1642127600629.jpg)

## 分组

除了简单判断是否匹配之外，正则表达式还有提取子串的强大功能。用()表示的就是要提取的分组(Group)。例如`^(\d{3})-(\d{3,8})$`分别定义了两个组，可以直接从匹配的字符串中提取出区号和本地号码

```python
import re
m = re.match(r'^(\d{3})-(\d{3,8})$','010-12345')
print(m.group(0))
print(m.group(1))
print(m.group(2))

# 结果
# 010-12345
# 010
# 12345
```

多个分组嵌套

```
Jan 1987
May 1969
May 1969
```

模式

```
([\w]{3} (\w{4}))
```

![image-20220114113529260](https://raw.githubusercontent.com/liang636600/cloudImg/master/images/image-20220114113529260.png)

## 切分字符串

例如`re.split(r'\s+',text)`将字符串按空白字符分割为列表

分隔符既有,又有;的情况

```
strs = re.split(r'[,;\s]+','a,b;; c d')
# ['a', 'b', 'c', 'd']
```

## re.findAll

返回的是一个列表，如果没有小括号，返回匹配到的字符串列表，如果有小括号，返回匹配到的字符串中小括号提取的值，例如

```python
# 有小括号
import re
mystr = '你真好你很好你非常好'
strs = re.findall(r'你(.*?)好',mystr) #结果['真', '很', '非常']

# pattern中有多个小括号,返回list，list中每个值为一个匹配结果中的提取值元组
import re
mystr = '你真好你很好你非常好'
strs = re.findall(r'你(.*?)好你(.*?)好',mystr) # 结果[('真', '很')]

# 没有小括号
import re
mystr = '你真好你很好你非常好'
strs = re.findall(r'你.*?好',mystr) # 结果 ['你真好', '你很好', '你非常好']
```

